{"version":3,"file":"main.js","mappings":"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","sources":["./src/app/app.component.ts","./src/app/app.component.html","./src/app/app.module.ts","./src/app/components/header/header.component.ts","./src/app/components/header/header.component.html","./src/app/components/question/question.component.ts","./src/app/components/question/question.component.html","./src/app/components/questions-list/questions-list.component.ts","./src/app/components/questions-list/questions-list.component.html","./src/app/components/search/search.component.ts","./src/app/components/search/search.component.html","./src/app/data/angular.array.ts","./src/app/data/nodejs.array.ts","./src/app/data/react.array.ts","./src/app/data/tech.stack.ts","./src/app/pipes/filter.pipe.ts","./src/app/pipes/highlighter.pipe.ts","./src/environments/environment.ts","./src/main.ts"],"sourcesContent":["import { Component } from '@angular/core';\r\nimport {techStackEnum} from \"./data/tech.stack\";\r\n\r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: ['./app.component.scss'],\r\n})\r\nexport class AppComponent {\r\n  public searchValue: string = '';\r\n  public technology: string = techStackEnum.REACT;\r\n}\r\n","<div class=\"wrapper\">\r\n  <div class=\"navbar\">\r\n    <app-header (onTech)=\"technology = $event\"></app-header>\r\n    <app-search class=\"search\" (onSearch)=\"searchValue = $event\"></app-search>\r\n  </div>\r\n\r\n  <app-questions-list\r\n    [technology]=\"technology\"\r\n    [searchText]=\"searchValue\"\r\n  ></app-questions-list>\r\n</div>\r\n","import { NgModule } from '@angular/core';\r\nimport { BrowserModule } from '@angular/platform-browser';\r\nimport { AppComponent } from './app.component';\r\nimport {FormsModule} from \"@angular/forms\";\r\nimport { HighlighterPipe } from './pipes/highlighter.pipe';\r\nimport { FilterPipe } from './pipes/filter.pipe';\r\nimport { QuestionComponent } from './components/question/question.component';\r\nimport { QuestionsListComponent } from './components/questions-list/questions-list.component';\r\nimport { SearchComponent } from './components/search/search.component';\r\nimport { HeaderComponent } from './components/header/header.component';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n    HighlighterPipe,\r\n    FilterPipe,\r\n    QuestionComponent,\r\n    QuestionsListComponent,\r\n    SearchComponent,\r\n    HeaderComponent\r\n  ],\r\n\timports: [\r\n\t\tBrowserModule,\r\n\t\tFormsModule\r\n\t],\r\n  providers: [],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n","import {Component, EventEmitter, Output} from '@angular/core';\r\nimport {techStack, techStackEnum, TechStackType} from '../../data/tech.stack';\r\n\r\n@Component({\r\n  selector: 'app-header',\r\n  templateUrl: './header.component.html',\r\n  styleUrls: ['./header.component.scss'],\r\n})\r\nexport class HeaderComponent{\r\n  @Output() public onTech: EventEmitter<string> = new EventEmitter<string>();\r\n  public technology: string = techStackEnum.REACT;\r\n  public techStack: TechStackType = techStack;\r\n  public techStackArray: string[] = Object.values(techStackEnum);\r\n  public countOfQuestions: number = techStack[techStackEnum.REACT].length\r\n\r\n  public chooseTech(technology: string): void {\r\n    this.technology = technology;\r\n    this.countOfQuestions = techStack[this.technology as keyof TechStackType].length\r\n    this.onTech.next(this.technology);\r\n  }\r\n}\r\n","<div class=\"header\">\r\n  <p\r\n    class=\"technology\"\r\n    [ngClass]=\"{ active: tech === technology }\"\r\n    *ngFor=\"let tech of techStackArray\"\r\n    (click)=\"chooseTech(tech)\"\r\n  >\r\n    {{ tech }}\r\n    {{tech === technology ? '(' + countOfQuestions + ')' : ''}}\r\n  </p>\r\n</div>\r\n","import { Component, Input } from '@angular/core';\r\nimport { Question } from '../../question.interface';\r\n\r\n@Component({\r\n  selector: 'app-question',\r\n  templateUrl: './question.component.html',\r\n  styleUrls: ['./question.component.scss'],\r\n})\r\nexport class QuestionComponent {\r\n  @Input() public question!: Question;\r\n  @Input() public searchText: string = '';\r\n}\r\n","<div class=\"question\">\r\n  <h3 [innerHTML]=\"question.title | highlighter: searchText\"></h3>\r\n  <p class=\"en\" [innerHTML]=\"question.english | highlighter: searchText\"></p>\r\n  <p class=\"ua\" [innerHTML]=\"question.ukrainian | highlighter: searchText\"></p>\r\n</div>\r\n","import { Component, Input, OnChanges} from '@angular/core';\r\nimport { Question } from '../../question.interface';\r\nimport {techStack, TechStackType} from '../../data/tech.stack';\r\n\r\n@Component({\r\n  selector: 'app-questions-list',\r\n  templateUrl: './questions-list.component.html',\r\n  styleUrls: ['./questions-list.component.scss'],\r\n})\r\nexport class QuestionsListComponent implements OnChanges {\r\n  @Input() public searchText: string = '';\r\n  @Input() public technology!: string;\r\n  public questions: Question[] = techStack[this.technology as keyof TechStackType];\r\n\r\n  public ngOnChanges(): void {\r\n    this.questions = techStack[this.technology as keyof TechStackType];\r\n  }\r\n}\r\n","<div class=\"list\" *ngIf=\"questions.length\">\r\n  <app-question\r\n    class=\"question\"\r\n    *ngFor=\"let question of questions | filter: searchText\"\r\n    [question]=\"question\"\r\n    [searchText]=\"searchText\"\r\n  ></app-question>\r\n</div>\r\n","import { Component, EventEmitter, Output } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-search',\r\n  templateUrl: './search.component.html',\r\n  styleUrls: ['./search.component.scss'],\r\n})\r\nexport class SearchComponent {\r\n  @Output() public onSearch: EventEmitter<string> = new EventEmitter<string>();\r\n\r\n  public inputSearchValue(event: Event): void {\r\n    this.onSearch.next((event.target as HTMLInputElement).value);\r\n  }\r\n}\r\n","<input\r\n  type=\"search\"\r\n  (input)=\"inputSearchValue($event)\"\r\n  placeholder=\"Search question\"\r\n  class=\"input\"\r\n/>\r\n","import {Question} from \"../question.interface\";\r\n\r\nexport const angularArray = [\r\n  {\r\n    title: `Advantages of Angular?`,\r\n    english: `- Angular has exceptional support for typescript;\r\n- Detailed documentation;\r\n- Two-way data binding, which ensures exceptional behavior of the program, which minimizes the risk of possible errors;\r\n- MVVM (Model-View-ViewModel), which allows developers to work separately on the same section of the application, using the same data set;\r\n- Module system - Use of component dependencies related to modules and modularity in general;\r\n- The structure and architecture are specially designed for high scalability of the project`,\r\n    ukrainian: `- Angular має виняткову підтримку тайпскріпт;\r\n- Детальна документація;\r\n- Двостороння прив'язка даних, що забезпечує виняткову поведінку програми, що мінімізує ризик можливих помилок;\r\n- MVVM (Model-View-ViewModel), що дозволяє розробникам працювати окремо над одним секцією апки, використовуючи той самий набір даних;\r\n- Модульна система - використання залежностей компонентів, пов'язаних з модулями та модульністю в цілому;\r\n- Структура та архітектура спеціально розроблені для високої масштабованості проекту;\r\n`\r\n  },\r\n  {\r\n    title: `What is it SPA?`,\r\n    english: `SPA is a single-page web application, which modules are loaded only once.The main advantages of such interface are the fast operation of the application and the absence of reloading the website when switching to other pages.`,\r\n    ukrainian: `SPA - односторінковий веб-додаток, модулі якого завантажуються лиш один раз, основними перевагами такого інтерфейсу є швидка робота додатку та відсутність перезавантаження веб-сайту при переходах на інші сторінки.`\r\n  },\r\n  {\r\n    title: `Disadvantages of Angular`,\r\n    english: `variety of different structures make it difficult to learn compared to react;\r\nRelatively slow performance in view of various indicators. On the other hand, this can be easily solved by using the so-called ChangeDetectionStrategy, which helps to manually control the rendering process of components.;\r\n`, ukrainian: `різноманітність різних структур ускладнює навчання порівняно з реактом;\r\nВідносно низька продуктивність за різними показниками. З іншого боку, це можна легко вирішити за допомогою так званої ChangeDetectionStrategy, яка допомагає вручну контролювати процес відтворення компонентів;\r\n`\r\n  },\r\n  {\r\n    title: `What is it MVC?`,\r\n    english: `MVC is a structure that effectively separates the Business Logic from the user interface of the application;\r\n- Model contains data about an application. This lists all the information that should be relevant to the display. information access requirements and other checks;\r\n- View displays the data from the Model component. Any response from the user is also recognized and sent to the Controller component;\r\n- Controller is responsible for providing the data present in the Model to the View component and interpreting the user responses recognized by the View component;`,\r\n    ukrainian: `MVC — це структура, яка фактично відокремлює бізнес-логіку від інтерфейсу користувача програми;\r\n- Model містить дані про програму. Тут перераховано всю інформацію, яка має бути актуальною для відображення та вимоги доступу до інформації з інші перевірками;\r\n- View відображає дані з компонента Model. Будь-яка відповідь користувача також розпізнається та надсилається до компонента контролера;\r\n- Controller несе відповідальність за надання даних, наявних у моделі, компоненту View та інтерпретацію відповідей користувача, розпізнаних компонентом View;\r\n`\r\n  },\r\n  {\r\n    title: `What are the technologies used in Angular?`,\r\n    english: `Angular is a modern frontend JavaScript framework developed by Google.\r\nAngular uses TypeScript, which is a superscript of JavaScript.  TypeScript allows us to write JavaScript as a strongly typed language.  It also uses RxJS, which allows developers to better deal with asynchronous operations.`,\r\n    ukrainian: `Angular — це сучасний JavaScript frontend framework, розроблений Google.\r\nAngular використовує TypeScript, який є надбудовою JavaScript. TypeScript дозволяє нам писати JavaScript як строго типізовану мову. Ангуляр також використовує RxJS, що дозволяє розробникам краще працювати з асинхронними операціями.\r\n`\r\n  },\r\n  {\r\n    title: `How does an Angular application work?`,\r\n    english: `The working of Angular is based on its components. So the working of the Angular application starts with the configuration file ANGULAR.JSON.The builder refers to this file to find the paths, configurations and the main file.  Next comes the MAIN.TS file that acts as the entry point for the configuration file. Next, the bootstrapping of the Angular application is done through the APP.MODULE.TS. In the App module, at @NgModule decorator array, we have a bootstrap Array. Here the bootstrap component is provided or added, so at this point, Angular loads AppComponent.`,\r\n    ukrainian: `Робота Angular базується на його компонентах. Таким чином, робота програми Angular починається з файлу конфігурації ANGULAR.JSON. Билдер посилається на цей файл, щоб знайти шляхи, конфігурації та основний файл(main.ts). Далі йде файл MAIN.TS, який діє як точка входу для файлу конфігурації. Далі завантаження програми Angular виконується через APP.MODULE.TS. У модулі програми в масиві декораторів @NgModule ми маємо  bootstrap масив. Тут надається або додається компонент початкового завантаження, тому на цьому етапі Angular завантажує AppComponent.`\r\n  },\r\n  {\r\n    title: `What are the directives? What is the difference between a structure directive and an attribute directive?`,\r\n    english: `Directives in Angular are used to manipulate the DOM tree. We use structural directives to work with the structure of the DOM tree (deletion, iteration, etc.). Attribute directives do not affect the HTML structure, only the styling of the HTML element.`,\r\n    ukrainian: `Директиви в Angular використовуються для маніпуляцій з DOM деревом. Структурні директиви ми використовуємо для  роботи зі структурою DOM дерева(видалення, ітерування і.т.д.). Атрибутні директиви не впливають на HTML структуру а тільки на стилізацію HTML елементу.`\r\n  },\r\n  {\r\n    title: `What is the ng-template, ng-container, ng-content?`,\r\n    english: `ng-template is a template element that Angular uses with structural directives (*ngIf, *ngFor, [ngSwitch] and custom directives)\r\nng-container - allows us to use structural directives without any extra element, making sure that the only DOM changes being applied are those dictated by the directives themselves.\r\nng-content allows parent components to inject HTML code into child components.\r\n`,\r\n    ukrainian: `ng-template — це елемент шаблону, який Angular використовує зі структурними директивами (*ngIf, *ngFor, [ngSwitch] і спеціальними директивами)\r\nng-container — дозволяє нам використовувати структурні директиви без будь-яких додаткових елементів, гарантуючи, що єдині зміни DOM, які застосовуються, є тими, що продиктовані самими директивами.\r\nng-content дозволяє батьківським компонентам вставляти HTML-код у дочірні компоненти.`\r\n  },\r\n  {\r\n    title: `Why do we use asterisks with structural directives?`,\r\n    english: `Directive without asterisk can only be applied to a (<template>) element.\r\nDirective with asterisk can be applied to any element. When used the (<template>) element is created behind the scene`,\r\n    ukrainian: `Директиву без зірочки можна застосувати лише до елемента (<template>).\r\nДиректива із зірочкою може бути застосована до будь-якого елемента. У разі використання елемент <template> створюється за кадром.\r\n`\r\n  },\r\n  {\r\n    title: `What is interpolation in angular?`,\r\n    english: `Interpolation in Angular is a special \"{{}}\"(with double closed curly brackets) syntax used to dynamically pass data in a template.`,\r\n    ukrainian: `Інтерполяція в Angular — це спеціальний синтаксис \"{{}}\" (з подвійними закритими фігурними дужками), який використовується для динамічної передачі даних у шаблоні.`\r\n  },\r\n  {\r\n    title: `What is  scope in angular?`,\r\n    english: `$scope - it's an automatic bridge between JavaScript and the DOM that holds synchronized data. This makes templating easier.\r\n$RootScope is the top-level $scope object from which all other scope objects are created. After Angular starts rendering the app, the framework creates a $rootScope object, and all subsequent bindings and logic in your app add new $scope objects that are children of $rootScope.\r\n`,\r\n    ukrainian: `$scope - це автоматичний міст між JavaScript і DOM, який тримає в собі синхронізовані дані. Це робить шаблонізацію більш простою.\r\n$RootScope - це самий верхній рівень $scope-об'єкта, від якого якого створюються всі інші об'єкти області видимості. Після того, як Angular починає рендер додатка, фреймворк створює $rootScope-об'єкт, і всі подальші прив'язки і логіка вашого додатка додають нові $scope-об'єкти, які є дітьми $rootScope.\r\n`\r\n  },\r\n  {\r\n    title: `What are the services in angular?`,\r\n    english: `Angular services are objects that are created only once during the lifetime of the application. They contain methods that maintain data throughout the life of the application, meaning that the data is always available.\r\nThe main objective of a service is to organize and share business logic, models, or data and functions with different components of an Angular application. They are usually implemented through dependency injection.\r\n`,\r\n    ukrainian: `Сервіси Angular — це об’єкти, які створюються лише один раз протягом життя програми. Вони містять методи, які зберігають дані протягом усього життя програми, тобто дані завжди доступні.\r\nОсновна мета сервісу полягає в організації та обміні бізнес-логікою, моделями або даними та функціями з різними компонентами програми Angular. Зазвичай вони впроваджуються через паттерн dependency injection.\r\n`\r\n  },\r\n  {\r\n    title: `What are the modules in angular?`,\r\n    english: `The module is a separate independent part of a web application. In the module, we register components, services, additional libraries related to it. It is a good practice to divide the application into modules, then it will work quickly regardless of its scale.`,\r\n    ukrainian: `Модуль - це окрема незалежна частина веб-додатку. В модулі реєструються компоненти, сервіси, додаткові бібліотеки, які відносяться до нього. Хорошою практикою вважається розділення додатку на модулі, тоді він працюватиме швидко в не залежності від його масштабу.`\r\n  },\r\n  {\r\n    title: `What are the components in angular?`,\r\n    english: `Component is the minimal unit for building user interfaces of web applications in Angular. It is a separate entity that includes the logical part in the .ts file, the markup in the .html file, and the styling file or files. A component must be part of a module and can be exported, allowing it to be reused in other modules.`,\r\n    ukrainian: `component - це мінімальна одиниця побудови користувацьких інтерфейсів веб додатків в Angular. Це окрема сутність, що включає логічну частину  в .ts файлі, розмітку в .html  файлі і файл або файли стилізації. Компонента повинна бути частиною модуля і може бути експортованою, що дозволить її перевикористовувати в інших модулях.`\r\n  },\r\n  {\r\n    title: `What are the lazy loading in angular?`,\r\n    english: `Lazy loading is an approach to load the modules that the user currently needs.\r\nBy default, Angular uses eager loading to load modules. This means that all the modules must be loaded before the application can be run.\r\n`,\r\n    ukrainian: `lazy loading — це підхід до завантаження модулів, які потрібні користувачеві в поточний момент.\r\nЗа замовчуванням Angular використовує швидке завантаження для завантаження модулів. Це означає, що перед запуском програми необхідно завантажити всі модулі.\r\n`\r\n  },\r\n  {\r\n    title: `What is Angular Data Binding?`,\r\n    english: `Data binding is a technique, where the data stays in synchronization between the component and the view. Angular uses two-way data binding\r\n( Whenever the user updates the data in the view, Angular updates the component. When the component gets new data, the Angular updates the view.). There is following types of data binding in angular: interpolation, property binding [], event binding ().\r\n`,\r\n    ukrainian: `Data binding — це техніка, за якої дані залишаються синхронізованими між компонентом і ui інтерфейсом. Angular використовує двосторонню прив’язку даних\r\n(Щоразу, коли користувач оновлює дані в ui інтерфейсі, Angular оновлює компонент. Коли компонент отримує нові дані, Angular оновлює ui інтерфейс). В Angular існують наступні типи зв’язування даних: інтерполяція, зв’язування властивостей [], зв’язування події ().\r\n`\r\n  },\r\n  {\r\n    title: `What are the decorators in angular?`,\r\n    english: `decorator is a function that allows you to dynamically connect certain behavior to a class. There are 4 types of decorators in Angular: Class decorators, Property Decorators Method decorators, Parameter decorators. The use of decorators makes it possible to clearly divide the code into logical parts for future reusing.`,\r\n    ukrainian: `декоратор - це функція яка дає можливість динамічно підключати певну поведінку для класу. В ангулярі існує 4 типи декораторів: Class decorators, Property Decorators Method decorators, Parameter decorators. Використання декораторів дає можливість чітко розподілити код на логічні частини, для подальшого перевикористання.`\r\n  },\r\n  {\r\n    title: `What are the @output and @input in angular?`,\r\n    english: `@Input() and @Output() allow Angular to exchange data between a parent context and child directives or components. The @Input() property is writable and the @Output() property is observable.\r\n@Input() allows a parent component to update data in a child component. Conversely, @Output() allows the child component to send data to the parent component. @Output binds the property using the angular EventEmitter class type.\r\n`,\r\n    ukrainian: `@Input() і @Output() дозволяють Angular обмінюватися даними між батьківським контекстом і дочірніми директивами або компонентами. Властивість @Input() доступна для запису, а властивість @Output() це observable.\r\n@Input() дозволяє батьківському компоненту оновлювати дані в дочірньому компоненті. І навпаки, @Output() дозволяє дочірньому компоненту надсилати дані до батьківського компонента. @Output прив’язує властивість за допомогою типу класу angular EventEmitter.\r\n`\r\n  },\r\n  {\r\n    title: `What is the event emitter in angular?`,\r\n    english: `The EventEmmiter class in Angular is an extension of the Subject class and has methods .emit() - for writing data and .subscribe(), which listens for changes in EventEmmiter.It works with the @Output() decorator, which in turn is an event handler`,\r\n    ukrainian: `Клас EventEmmiter в Angular є розширенням класу Subject і має методи .emit() для запису даних і .subscribe(), який відстежує зміни в EventEmmiter. Він працює з декоратором @Output(), який, у свою чергу, обробник подій.`\r\n  },\r\n  {\r\n    title: `What the differences between promises and observables`,\r\n    english: `Promise handles a single event when an async operation completes or fails.\r\nAn Observable is like a Stream (in many languages) and allows to pass zero or more events where the callback is called for each event.\r\nPromise starts immediately, an Observable only starts if you subscribe to it.\r\n`,\r\n    ukrainian: `Promise обробляє одну подію, коли асинхронна операція завершується або завершується помилкою.\r\nObservable схожий на Stream (в багатьох мовах) і дозволяє передавати нуль або більше подій, де для кожної події викликається зворотний виклик.\r\nPromise запускається негайно, Observable запускається, лише якщо ви підписалися на нього.\r\n`\r\n  },\r\n  {\r\n    title: `What is the dependency injection and where it uses?`,\r\n    english: `dependency injection is a pattern that allows one object to be used by many other objects without creating a new instance each time.\r\nFor this, Angular uses the @Injectable() decorator. The most common example of using dependency injection in Angular is services\r\n`,\r\n    ukrainian: `dependency injection - це патерн, який дозволяє використовувати один об'єкт, багатьма іншими об'єктами при цьому не створювати кожного разу новий екземпляр.\r\nДля цього в ангулярі використовується декоратор @Injectable(). Набільш поширеним прикладом використання dependency injection в ангулярі - це сервіси\r\n`\r\n  },\r\n  {\r\n    title: `What is the purpose of async pipe?`,\r\n    english: `Async pipe - designed for asynchronous data processing. Used in html file. In the case of working with RxJs, it subscribes to the stream and unsubscribes when the component is destroyed.`,\r\n    ukrainian: `Async pipe - призначена для обробки асинхронних даних. Використовується в html файлі. У випадку роботи із RxJs, підписується на стрім і коли компонента дестроїться, відписується.`\r\n  },\r\n  {\r\n    title: `What is the MVVM?`,\r\n    english: `MVVM(Model => View => ViewModel) - application architecture design template. It is used to separate the model and its representation. It is convenient to use in cases where the data binding in the development framework.\r\nThe model is the logic of working with the data and the description of the data\r\nView is a graphical interface\r\nViewModel - on the one hand, it is a View, and on the other, it is a data wrapper from the Model\r\n`,\r\n    ukrainian: `MVVM(Model => View => ViewModel) - шаблон проектування архітектури додатку. Він використовується для для розділення моделі і ui інтерфейсу. Його зручно використовувати в тих випадках, коли в фреймворку де ведеться розробка є зв'язування даних.\r\nМодель - це логіка роботи з даними і опис даних\r\nView - це графічний інтерфейс\r\nViewModel -  з одної сторони це View, а з другої це обгортка даних з Моделі.\r\n`\r\n  },\r\n  {\r\n    title: ` What is the AOT compilation?`,\r\n    english: `AOT or Ahead-of-Time is a variant of application compilation (alternative to JIT or Just-in-time), which is performed once when the application is assembled. The JIT is executed every time the application is launched in the browser.\r\nThanks to this version of the compilation, the application starts up faster. The compiled file is smaller. Templates are compiled prematurely before assembly\r\n`,\r\n    ukrainian: `AOT або Ahead-of-Time – це варіант компиляции додатку(альтернатива JIT або Just-in-time), яка виконується один раз при збірці додатку. JIT виконується кожен раз при запуску додатку в браузері.\r\nЗавдяки цьому варіанту компіляції відбувається більш швидкий запуску додатку. Скомпільований файл виходить меншим.Шаблони компілюються передчасно до збірки\r\n`\r\n  },\r\n  {\r\n    title: `How routing system works in angular?`,\r\n    english: `Routing in Angular is organized using the Router module. To go to another page, it is enough for us to specify the path and the component that will be displayed when going to it. For the speed of the web application, its pages are divided into modules, in this case, when switching to a certain route, we load the corresponding module, inside which we specify which components need to be displayed.`,\r\n    ukrainian: `Організація роутингу в ангулярі відбувається за допомогою Router module. Для переходу на іншу сторінку нам достатньо вказати шлях і компонент, який відображатиметься при переході на нього. Для швидкодії веб-додатку його сторінки поділяють на модулі, у такому випадку при переході на певний роут ми підвантажуємо відповідний модуль, всередині якого вказуємо які компоненти потрібно відобразити.`\r\n  },\r\n  {\r\n    title: `difference between subjects and observables?`,\r\n    english: `Subject is an Observable type that allows not only to send something from its stream (as an Observable), but also to receive it, and Subject can also subscribe to other Observables`,\r\n    ukrainian: `Subject це тип Observable, який дозволяє не тільки відправляти щось зі свого потоку(як Observable), але і приймати до себе, також Subject може підписуватися на інші Observable\r\n`\r\n  },\r\n  {\r\n    title: `difference between Subject, ReplaySubject and BehaviorSubject?`,\r\n    english: `The difference between Subject and BehaviorSubject is that BehaviorSubject must have an initial value. ReplaySubject can store old subscription values, for this you need to specify the number of subscriptions it will store when creating ReplaySubject`,\r\n    ukrainian: `Різниця між Subject і BehaviorSubject полягає в тому, що BehaviorSubject обов'язково повинен мати початкове значення. ReplaySubject може зберігати старі значення підписок, для цього при створенні ReplaySubject потрібно вказати кількість підписок, які він буде зберігати`\r\n  },\r\n  {\r\n    title: `What is Data Binding? In how many ways can it be executed?`,\r\n    english: `Data binding is a core concept in Angular and allows to define communication between a component and the DOM, making it very easy to define interactive applications without worrying about pushing and pulling data. There are four forms of data binding and they differ in the way the data is flowing.\r\n - Interpolation: {{ value }}\r\n-  Property binding: [property]=“value”\r\n- Event binding: (event)=“function”\r\n- Two-way data binding: [(ngModel)]=“value”\r\n`,\r\n    ukrainian: `Data binding є основною концепцією в Angular і дозволяє визначати зв’язок між компонентом і DOM, завдяки чому дуже легко визначати інтерактивність, не турбуючись про надсилання та отримання даних. Існує чотири форми зв’язування даних, які відрізняються способом передачі даних.\r\n - Interpolation: {{ value }}\r\n-  Property binding: [property]=“value”\r\n- Event binding: (event)=“function”\r\n- Two-way data binding: [(ngModel)]=“value”\r\n`\r\n  },\r\n  {\r\n    title: `What are the pipes?`,\r\n    english: `Pipes are simple functions to use in template expressions to accept an input value and return a transformed value. Pipes are useful because you can use them throughout your application, while only declaring each pipe once.`,\r\n    ukrainian: `Пайпи — це прості функції, які використовуються у виразах шаблонів для прийняття вхідного значення та повернення перетвореного значення. Пайпи корисні, оскільки можна використовувати їх у своєму додатку, оголошуючи кожен пайп лише один раз.`\r\n\r\n  },\r\n  {\r\n    title: `What is the difference between pure and impure pipe?`,\r\n    english: `The difference between pure and impure is that a pure pipe will always return the same value given the same input. A clean pipe does not have its own status and does not depend on external factors. A dirty or impure pipe can have its own state, which will affect the result. Also, a dirty pipe will create a separate instance of the class to handle the data.`,\r\n    ukrainian: `Різниця між pure і impure полягає в тому, що чиста пайпа завжди поверне однакове значення при однакових вхідних даних. Чиста пайпа немає свого стейту і не залежить від зовнішніх чинників. Брудна або impure пайпа може мати свій стейт, який буде впливати на результат. Також брудна пайпа буде створювати окремий екземпляр класу для обробки даних.`\r\n  },\r\n  {\r\n    title: `What are observables?`,\r\n    english: `Observable is the name of the mechanism that works with an asynchronous flow, in Angular Observable is most often found in http requests and in triggers in the code`,\r\n    ukrainian: `Observable це назва механізму який працює з асинхронним потоком,в Angular найчастіше зустрічається Observable в http запитах і в тригерах в коді`\r\n  },\r\n  {\r\n    title: `What is a bootstrapping module?`,\r\n    english: `bootstrapping module specifies the initial module of the web application. Inside the initial module in the @NgModule decorator, we write the bootstrap parameter in which we specify the initial component.`,\r\n    ukrainian: `за допомогою bootstrapping module вказується початковий модуль веб-додатку. Всередині початкового модулю у декораторі @NgModule ми пишемо параметр bootstrap у якому вказуємо початковий компонент.`\r\n  },\r\n  {\r\n    title: `How is Dependency Hierarchy formed?`,\r\n    english: `A hierarchical dependency allows us to define different boundaries or scopes for our dependencies to run in and follows the component tree structure. By default, services registered to Angular are application wide but we can also create services that are isolated to a subset of components.`,\r\n    ukrainian: `Ієрархічна система залежностей дозволяє нам визначати різні межі або області для виконання наших залежностей і слідує структурі дерева компонентів. За замовчуванням сервіси, зареєстровані в Angular, є загальнодоступними, але ми також можемо створювати сервіси, що ізольовані від інших компонентів.`\r\n  },\r\n  {\r\n   title: `How do you perform Error handling?`,\r\n   english: `I use ErrorHandler to handle errors in Angular. This is a flexible way of catching and handling errors in an Angular application. However, the most reliable way to handle server and connection errors is to use HttpErrorResponse in HttpInterceptor. Angular also has the ability to track errors in real-time using the Rollbar. This approach significantly improves the processes of monitoring, diagnosis and analysis. The SDK for Angular from Rollbar allows you to conveniently integrate its functions into a global interface for convenient work with error handling.`,\r\n   ukrainian:`Для обробки помилок в Angular я використовую ErrorHandler. Це гнучкий спосіб відловлювання і обробки помилок в Angular додатку. Проте найбільш надійним способом обробки серверних помилок та помилок пов'язаних з підключенням є використання HttpErrorResponse в HttpInterceptor. Також в Angular є можливість відстежувати помилки в режимі реального часу за допомогою Rollbar. Такий підхід значно покращує процеси моніторингу, діагностики та аналізу. Пакет SDK для Angular від Rollbar дозволяє зручно інтегрувати його функції в глобальний інтрецептор, для зручної роботи з обробкою помилок.`,\r\n  },\r\n  {\r\n    title: `What is HttpClient and its benefits?`,\r\n    english: `The http client is a service used to send http requests, which are handled by the HttpClientModule. All methods of this service return a response with type Observable, which makes it possible to use rxjs methods to work with data.`,\r\n    ukrainian: `http client - це сервіс, який використовується для надсилання http запитів, за відпрацювання яких відповідає HttpClientModule. Усі методи цього сервісу повертають відповідь з типом Observable, що дає можливість використовувати методи rxjs для роботи з даними.`,\r\n  },\r\n  {\r\n    title: `What will happen if you do not supply error handlers for observer?`,\r\n    english: `If you do not handle the error in the observables, then they fall into the global error handler of Angular.`,\r\n    ukrainian: `Якщо не обробити помилку в observables, то вони потрапляють в глобальний обробник помилок ангуляру. `,\r\n  },\r\n  {\r\n    title: `Error handling in rxjs`,\r\n    english: `The operators like catchError,retryWhen, retry provide effective ways to gracefully handle errors and retry logic, should they occur`,\r\n    ukrainian: `Такі оператори, як catchError, retryWhen, retry, надають ефективні способи елегантної обробки помилок і логіки повторних спроб, якщо вони трапляються`,\r\n  },\r\n  {\r\n    title: `difference between retry and retryWhen rxjs?`,\r\n    english: `These operators help us to retry a failed observable in Angular. They both resubscribe to the source observable when they receive onError() notification. The ReTry Angule RxJs operator retries a failed source observable count number of times. If the count is not provided then it tries indefinitely. The RetryWhen operator retries the failed Observable every time a Notification Observable emits the next value. RetyWhen is now deprecated and we should use Retry instead it`,\r\n    ukrainian: `Ці оператори допомагають нам повторити спробу невдалого Обсерваблу. Вони обоє повторно підписуються на спостережуване джерело, коли отримують сповіщення onError(). Оператор ReTry  повторює невдалу кількість спостережуваних джерел енну кількість разів. Якщо підрахунок не надано, спроба виконується нескінченно. Оператор RetryWhen повторює помилку Observable кожного разу, коли Notification Observable видає наступне значення. RetyWhen тепер застаріло, і ми повинні використовувати Retry замість нього`,\r\n  },\r\n  {\r\n    title: `what is the observer?`,\r\n    english: `An Observer is a consumer of the values provided by the Observable. Observers are simply a collection of callbacks, one for each type of message delivered by the Observable: next , error , and complete`,\r\n    ukrainian: `Observer - це споживач значень, що надаються Observable. Спостерігачі - це просто набір зворотних дзвінків, по одному для кожного типу повідомлення, доставленого Observable: next , error і complete`,\r\n  },\r\n  {\r\n    title: `difference between observer and observables?`,\r\n    english: `Observer : Any object that wishes to be notified when the state of another object changes. Observable : Any object whose state may be of interest, and in whom another object may register an interest.`,\r\n    ukrainian: `Observer: будь-який об’єкт, який бажає отримувати повідомлення про зміну стану іншого об’єкта. Observable: Будь-який об’єкт, стан якого може становити інтерес, і до якого інший об’єкт може зареєструвати інтерес.`,\r\n  },\r\n  {\r\n    title: `what is the cold Observables?`,\r\n    english: `A cold observable starts producing data when some code invokes a subscribe() function on it. For example, your app may declare an observable providing a URL on the server to get certain products. The request will be made only when you subscribe to it. If another script makes the same request to the server, it will get the same set of data.`,\r\n    ukrainian: `Cold observable починає створювати дані, коли якийсь код викликає subscribe() на них. Наприклад, ваша програма може оголосити Observable, що надає URL-адресу на сервері для отримання певних продуктів. все буде зроблено тільки тоді, коли ви на неї підпишетеся. Якщо надсилається такий самий запит серверу, він отримає такий самий набір даних.`,\r\n  },\r\n  {\r\n    title: `what is the hot observables?`,\r\n    english: `Hot observables are ones that are pushing event when you are not subscribed to the observable. Like mouse moves, or Timer ticks or anything like that. Cold observables are ones that start pushing only when you subscribe, and they start over if you subscribe again.`,\r\n    ukrainian: `Hot observables надають дані про подію, навіть коли нема підписки на обсервабл. Наприклад, рухи миші чи щось подібне`,\r\n  },\r\n  {\r\n    title: `difference between hot and cold observables?`,\r\n    english: `Anyone who decides to watch Mission: Impossible on Netflix will get the entire movie, regardless of when they hit the play button. Netflix creates a new producer to stream a movie just for you. This is a cold observable. If you go to a movie theater and the showtime is 4 p.m., the producer is created at 4 p.m., and the streaming begins. If some people (subscribers) are late to the show, they miss the beginning of the movie and can only watch it starting from the moment of arrival. This is a hot observable.`,\r\n    ukrainian: `Кожен, хто вирішить подивитися «Місія нездійсненна» на Netflix, отримає повний фільм, незалежно від того, коли він натиснув кнопку відтворення. Netflix створює новий стрім для трансляції фільму спеціально для вас. Це cold observable. Якщо ви йдете в кінотеатр, а сеанс починається о 16:00, стрім створюється о 16:00 і починається трансляція. Якщо деякі люди (subscribers) запізнюються на сеанс, вони пропускають початок фільму і можуть дивитися його тільки з моменту приходу. Це hot observable.`,\r\n  },\r\n  {\r\n    title: `How do you define typings for custom elements?`,\r\n    english: `for this you need to use the NgElement and WithProperties types, which are exported from @angular/elements`,\r\n    ukrainian: `для цього потрібно використати типи NgElement і WithProperties, які експортуються з @angular/elements`,\r\n  },\r\n  {\r\n    title: `What are router events?`,\r\n    english: `Router events are events that work at different phases of the router. We can subscribe to these events (router.events.subscribe). There are such router events as NavigationStart, RouteConfigLoadStart, RouteConfigLoadEnd, RoutesRecognized, GuardsCheckStart, ChildActivationStart, ActivationStart, GuardsCheckEnd, ResolveStart, ResolveEnd, ActivationEnd, ChildActivationEnd, NavigationEnd, Scroll, NavigationCancel, NavigationError.`,\r\n    ukrainian: `Router events - це події, які відпрацьовують на різних фазах роботи роуту. Ми можемо засабскрайбитись на ці події(router.events.subscribe). Є такі Івенти роутераЖ NavigationStart, RouteConfigLoadStart, RouteConfigLoadEnd, RoutesRecognized, GuardsCheckStart, ChildActivationStart, ActivationStart, GuardsCheckEnd, ResolveStart, ResolveEnd, ActivationEnd, ChildActivationEnd, NavigationEnd, Scroll, NavigationCancel, NavigationError`,\r\n  },\r\n  {\r\n    title: `What is activated route?`,\r\n    english: `ActivatedRoute is a service that is provided to each component in the route, it contains information about the route, such as route parameters, static data and so on`,\r\n    ukrainian: `ActivatedRoute це служба яка надається кожному компоненту в маршруті, вона містить інформацію про маршрут, такі як параметри маршруту,статичні дані і так далі`,\r\n  },\r\n  {\r\n    title: `What is router outlet?`,\r\n    english: `router outlet is a directive with the help of which we explicitly indicate where exactly the component will be displayed at a certain route. Several router outlets can be used on the project to build convenient application routing`,\r\n    ukrainian: `router outlet - це директива, за допомогою якої ми явно вказуємо де саме буде відображатись компонент при певному роуті. На проекті можна використовувати кілька router outlet для побудови зручної маршрутизації додатку`,\r\n  },\r\n  {\r\n    title: `How do you specify angular template compiler options?`,\r\n    english: ``,\r\n    ukrainian: `Ми можемо налаштовувати опції конфігурації в файлі tsconfig.json, tsconfig.app.json`,\r\n  },{\r\n    title: `angular template compiler options`,\r\n    english: `disableExpressionLowering, flatModuleId, fullTemplateTypeCheck, generateCodeForLibraries, trace etc`,\r\n    ukrainian: `disableExpressionLowering, flatModuleId, fullTemplateTypeCheck, generateCodeForLibraries, trace ітдщ`,\r\n  },{\r\n    title: `What is Non null type assertion operator?`,\r\n    english: `Non null type assertion operator is an operator with the help of which it is explicitly indicated that the value of the operand is not null and not undefined. !`,\r\n    ukrainian: `Non null type assertion operator - це оператор за допомогою якого явно вказують, що значення операнду не null і не undefined. !`,\r\n  },{\r\n    title: `What are the steps to use animation module?`,\r\n    english: `1)import BrowserAnimationsModule to add animation capabilities to the root module of your Angular application (eg src/app/app.module.ts).2)import the necessary animation functions from @angular/animations into component files (eg src/app/app.component.ts).3) add a metadata property called animations: to the @Component() decorator in component files (eg src/app/app.component.ts)`,\r\n    ukrainian: `1)імпортувати BrowserAnimationsModule, щоб додати можливості анімації у кореневий модуль програми Angular (наприклад, src/app/app.module.ts).2)імпортувати необхідні функції анімації з @angular/animations у файли компонентів (наприклад, src/app/app.component.ts).3)додати властивість метаданих під назвою animations: у декоратор @Component() у файлах компонентів (наприклад, src/app/app.component.ts)`,\r\n  },\r\n  {\r\n    title: `What is zone?`,\r\n    english:`In the context of js, there is a zonejs library that is designed to catch asynchronous operations and, if necessary, notify about them. In the context of Angular, the core of the framework is ngZone, which is based on zonejs. Angular mostly uses ngZone to notify the application core about state changes. In Angular, the Change detection mechanism is triggered and rerenders the html tree.`,\r\n    ukrainian: `Zone в перекладі з англійської, це тюрма. В контексті js, є бібліотека zonejs яка створена для того, щоб відловлюати асинхронні операції і при необхідності сповіщати про них. В контексті Angular в ядрі фреймворку є ngZone в основі якого лежить zonejs. Здебільшого Angular використовує ngZone для сповіщення ядра програми про зміни стану. В Angular спрацьовує механізм Change detection і перерендрює html дерево.`,\r\n  },\r\n  {\r\n    title: `What is State function?`,\r\n    english:`state function define different states to call at the end of each transition in animation. This function takes two arguments: A unique name like open or closed and a style() function.`,\r\n    ukrainian: `state function визначає різні стани для виклику в кінці кожного переходу в анімації. Ця функція приймає два аргументи: унікальне ім’я, наприклад відкритий або закритий, і функцію style().`,\r\n  },\r\n  {\r\n    title: `What are macros in angular?`,\r\n    english:`Macros that are microtasks of angular aot compiler in the form of functions or static methods that return an expression. For example The Angular RouterModule exports two macro static methods, forRoot and forChild, to help declare root and child routes.`,\r\n    ukrainian: `Макрос це мікрозавдання компілятора angular aot у формі функцій або статичних методів, які повертають вираз. Наприклад, Angular RouterModule експортує два макро-статичні методи, forRoot і forChild, щоб допомогти оголосити кореневий і дочірній маршрути`,\r\n  },\r\n  {\r\n    title: `How do you describe various dependencies in angular application?`,\r\n    english:`Dependency injection, or DI, is one of the fundamental concepts in Angular. DI is wired into the Angular framework and allows classes with Angular decorators, such as Components, Directives, Pipes, and Injectables, to configure dependencies that they need.`,\r\n    ukrainian: `Впровадження залежностей, або DI, є однією з фундаментальних концепцій Angular. DI підключено до фреймворку Angular і дозволяє класам із декораторами Angular, такими як Components, Directives, Pipes і Injectables, налаштовувати потрібні їм залежності.`,\r\n  },\r\n  {\r\n    title: `What is provider in module?`,\r\n    english:`A provider is an instruction to the Dependency Injection system on how to obtain a value for a dependency. Most of the time, these dependencies are services that you create and provide`,\r\n    ukrainian: `provider — це інструкція для системи Dependency Injection щодо того, як отримати значення для залежності. У більшості випадків ці залежності — це служби, які ви створюєте та надаєте`,\r\n  },\r\n  {\r\n    title: `What is rxjs?`,\r\n    english:`RxJS is a Javascript library for transforming, composing, and extracting asynchronous data streams. It can be used both in the browser and on the server side`,\r\n    ukrainian: `RxJS – це Javascript бібліотека для трансформації, складання та вилучення асинхронних потоків даних. Вона може бути використана як у браузері, так і на стороні сервера`,\r\n  },\r\n  {\r\n    title: `What is Angular CLI Builder?`,\r\n    english:`Angular CLI Builder is a tool for customizing how Angular CLI works. With its help, you can create new scenarios or change existing ones`,\r\n    ukrainian: `Angular CLI Builder - це інструмент для кастомізації роботи Angular CLI. За допомогою нього можна створювати нові сценарії, або змінювати інсуючі`,\r\n  },\r\n  {\r\n    title: `What are the limitations with web workers?`,\r\n    english:`the web worker cannot directly manipulate the DOM and has limited access to the window object's methods and properties`,\r\n    ukrainian: `web worker не може безпосередньо маніпулювати DOM і має обмежений доступ до методів і властивостей віконного об’єкта`,\r\n  },\r\n  {\r\n    title: `Difference between concatMap i mergeMap`,\r\n    english:`concatMap: behaves like a queue: stores all calls and sends them one by one. If one is completed, the next one is processed. mergeMap : Also sends all requests like concatMap, but does not wait for a response. It sends them as they come`,\r\n    ukrainian: `concatMap: поводиться як черга: зберігає всі виклики та надсилає один за одним. Якщо один завершений, наступний обробляється. mergeMap : також надсилає всі запити, як concatMap, але не чекає, доки прийде відповідь. Він посилає їх, як вони приходять`,\r\n  },\r\n  {\r\n    title: `What are the three phases of AOT?`,\r\n    english:`the compiler works in 3 phases 1. Code Analysis. The TypeScript compiler analyzes the code and checks the code for syntax errors 2. Code generation. The StaticReflector compiler parses the data that was analyzed in the first phase of compilation, additionally checks for errors and generates the final code.3. Template type checking. This is an additional compilation stage that uses the TypeScript compiler to check relationships, expressions in patterns`,\r\n    ukrainian: `компілятор працює в 3 фази 1. Code Analysis. Компілятор TypeScript  аналізує код, та перевіряє код на синтаксичні помилки 2. Code generation. Компілятор StaticReflector розбирає дані, які були проаналізовані на першій фазі компіляції, додатково перевіряє на помилки та генерує фінальний код. 3. Template type checking. Це додатковий етап компіляції, який використовує компілятор TypeScript для перевірки зв'язків, виразів у шаблонах`,\r\n  },\r\n  {\r\n    title: `What are webworkers in angular?`,\r\n    english:`Web workers in Angular is a technology that allows you to perform complex calculations in the background thread of the central processor, freeing the main thread to update the user interface`,\r\n    ukrainian: `Web workers в Angular це технологія яка дозволяє виконувати складні обчислення у фоновому потоці центрального процесора, звільняючи основний потік для оновлення інтерфейсу користувача`,\r\n  },\r\n  {\r\n    title: `What is a DI token?`,\r\n    english:`The Dependency Injection system in Angular uses tokens to uniquely identify a Provider. There are three types of tokens that you can create in Angular. They are Type Token, String Token, and Injection Token`,\r\n    ukrainian: `Система Dependency Injection в Angular використовує токени для унікальної ідентифікації постачальника. Є три типи токенів, які ви можете створити в Angular. Це маркер типу, маркер рядка та маркер ін’єкції`,\r\n  },\r\n  {\r\n    title: `What are the ways to trigger change detection?`,\r\n    english:`ApplicationRef.tick() - Used to explicitly handle change detection, the method checks the entire component tree. NgZone.run(callback) - accepts a callback function ChangeDetectorRef.detectChanges() - detects only components and their children.`,\r\n    ukrainian: `ApplicationRef.tick()  - використовується для того, щоб явно обробити виявлення змін, метод перевіряє повне дерево компонентів. NgZone.run(callback) - приймає калбек функцію ChangeDetectorRef.detectChanges() - детектить лише компоненти та їх дочірні елементи.`,\r\n  },\r\n  {\r\n    title: `What are the best practices for security in angular?`,\r\n    english:`Prevent cross-site scripting; Block HTTP-related vulnerabilities; Avoid untested APIs; Do not configure Angular files; Always try to use the latest versions of libraries for Angular;`,\r\n    ukrainian: `Запобігти cross-site scripting; Блокуйте вразливості, пов’язані з HTTP; Уникати неперевірених APIs; Не налаштовуйте файли Angular; Завжди старатися використовувати найновіші версії бібліотек для Angular;`,\r\n  },\r\n  {\r\n    title: `What is DOM sanitizer?`,\r\n    english: `DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing values to be safe to use in the different DOM contexts.These situations should be very rare, and extraordinary care must be taken to avoid creating a Cross Site Scripting (XSS) security bug!`,\r\n    ukrainian: `DomSanitizer допомагає запобігти помилкам безпеки міжсайтових сценаріїв (XSS). Він очищує значення, щоб вони були безпечними для використання в різних контекстах DOM. Такі ситуації мають бути дуже рідкісними, і потрібно бути надзвичайно обережним, щоб уникнути виникнення помилки безпеки міжсайтового сценарію (XSS)!`,\r\n  },\r\n  {\r\n    title: `What are Http Interceptors?`,\r\n    english:`HTTP Interceptors are a special type of angular service that we can implement. It is used to apply custom logic to a central point between an outgoing/incoming HTTP request and a client-side and server-side response.`,\r\n    ukrainian: `HTTP Interceptors — це особливий тип angular-сервісу, який ми можемо реалізувати. Він використовується для застосування спеціальної логіки до центральної точки між вихідним/вхідним HTTP-запитом і відповіддю на стороні клієнта та на стороні сервера.`,\r\n  },\r\n  {\r\n    title: `What is the purpose of i18n attribute?`,\r\n    english:`i18n is used to mark the text to be translated`,\r\n    ukrainian: `i18n використовується для маркування тексту що має бути перекладений`,\r\n  },\r\n  {\r\n    title: `What is select ICU expression?`,\r\n    english:`Mark choices for alternate text based on your defined string values`,\r\n    ukrainian: `Позначає варіанти для альтернативного тексту на основі визначених вами рядкових значень`,\r\n  },\r\n  {\r\n    title: `How do you provide build configuration for multiple locales?`,\r\n    english:`I Configure a server for preferred language defined in the browser using the Accept-Language HTTP header, we can implement that by nginx`,\r\n    ukrainian: `Я налаштовую сервер для бажаної мови, визначеної у браузері, використовуючи HTTP-заголовок Accept-Language, ми можемо реалізувати це за допомогою nginx`,\r\n  },\r\n  {\r\n    title:`What is router state?`,\r\n    english:`Angular RouterState is the state of the router in the form of a tree of activated routes. It specifies how the various components of the application are arranged on the screen to determine what should be displayed on it. RouterState represents the state of the router as it constantly changes over time as users move from page to page.`,\r\n    ukrainian:`Angular RouterState — це стан маршрутизатора у вигляді дерева активованих маршрутів.  Він вказує, як різні компоненти програми розташовані на екрані, щоб визначити, що на ньому має відображатися.  RouterState представляє стан маршрутизатора, оскільки він постійно змінюється з часом, коли користувачі переходять від сторінки до сторінки.`\r\n  },\r\n  {\r\n    title:`What is slice pipe?`,\r\n    english:`A pipe used to cut string. The first parameter indicates the index from which cut begins, the second indicates the index where it ends.`,\r\n    ukrainian:`Пайп, що використовується для обрізання стрінги. Першим параметром вказується індекс з якого починається обрізання, другим вказується індекс де завершується.`\r\n  },\r\n  {\r\n    title:` Is it all components generated in production build?`,\r\n    english:`No, only the entry components and template components appears in production builds. If a component isn't an entry component and isn't found in a template, the tree shaker will throw it away.`,\r\n    ukrainian:`Ні, лише ентрі компоненти та компоненти шаблонів відображаються у робочих збірках. Якщо компонент не є ентрі компонентом і не знайдений у шаблоні, шейкер дерева викине його.`\r\n  },\r\n  {\r\n    title:`How can I use interceptor for an entire application?`,\r\n    english:`You can use same instance of HttpInterceptors for the entire app by importing the HttpClientModule only in your AppModule, and add the interceptors to the root application module provider. `,\r\n    ukrainian:`Ви можете використовувати той самий екземпляр HttpInterceptors для всієї програми, імпортувавши HttpClientModule лише у свій AppModule і додавши перехоплювачі до providers`\r\n  },\r\n  {\r\n    title:`What is Sanitization? Is angular supports it?`,\r\n    english:`Sanitization is the inspection of an untrusted value, turning it into a value that's safe to insert into the DOM. In many cases, sanitization doesn't change a value at all. Sanitization depends on context: A value that's harmless in CSS is potentially dangerous in a URL.`,\r\n    ukrainian:`Sanitization — це перевірка ненадійного значення, перетворення його на значення, яке можна безпечно вставити в DOM. У багатьох випадках санітарна обробка взагалі не змінює значення. Sanitization залежить від контексту: нешкідливе значення в CSS потенційно небезпечне в URL-адресі.`\r\n  },\r\n  {\r\n    title:`What is a shared module?`,\r\n    english:`The shared module allows us to organize and optimize our code. We can create directives and components in one module and then import only that module anywhere else`,\r\n    ukrainian:`Shared module дозволяє нам упорядкувати та оптимізувати свій код. Ми можемо помістити  директиви та компоненти в один модуль, а потім імпортувати лише цей модуль у будь-яке інше місце`\r\n  },\r\n  {\r\n    title:`What is RouterStateSnapshot?`,\r\n    english:`is a tree of active routes. With its help, we have access to any parameters or segments of the current url`,\r\n    ukrainian:`What is RouterStateSnapshot? - це дерево активних роутів. За допомогою нього ми маємо доступ до будь-яких параметрів чи сегментів поточної юрли`\r\n  },\r\n  {\r\n    title:`What is ngcc? `,\r\n    english:`(Angular Compatibility Compiler) is a tool that updates node modules compiled with non-ivy ngc to an ivy-compatible format.`,\r\n    ukrainian:`What is ngcc? (Компілятор сумісності Angular) - це інструмент, який оновлює нод модулі, скомпільованих не за допомогою ivy ngc, у формат, сумісний з ivy.`\r\n  },\r\n  {\r\n    title:`What is NgZone?`,\r\n    english:`NgZone enables us to explicitly run certain code outside Angular's Zone, preventing Angular to run any change detection. So basically, handlers will still be executed, but since they won't run inside Angular's Zone, Angular won't get notified that a task is done and therefore no change detection will be performed`,\r\n    ukrainian:`NgZone дає нам змогу явно запускати певний код поза зоною Angular, не дозволяючи Angular запускати будь-яке виявлення змін. Таким чином, в основному, обробники все одно виконуватимуться, але оскільки вони не запускатимуться всередині зони Angular, Angular не отримуватиме сповіщень про виконання завдання, і тому виявлення змін не здійснюватиметься`\r\n  },\r\n  {\r\n    title:`What are the methods of NgZone used to control change detection?`,\r\n    english:`The run() method is used to execute API requests that are not handled by ngZone and automatically trigger change detection at the correct time. The runOutsideAngular() method also executes API requests, but does not trigger change detection`,\r\n    ukrainian:`Метод run() використовується для виконання API запитів, які не обробляються ngZone, і автоматично запускає виявлення змін у правильний час. Метод runOutsideAngular() теж для виконання API запитів,, але не запускає виявлення змін`\r\n  },\r\n  {\r\n    title:`Is it mandatory to use injectable on every service class?`,\r\n    english:`No. The @Injectable() decorator is not strictly required if the class has other Angular decorators on it or does not have any dependencies. But the important thing here is any class that is going to be injected with Angular is decorated.`,\r\n    ukrainian:`Ні, ми просто вказуєм, що сервіс може мати депенденсіс або не може`\r\n  },\r\n  {\r\n    title:`difference between private, public and protected,`,\r\n    english:`Private methods/members are accessible only from inside the class. Protected methods/members are accessible from inside the class and extending class as well.`,\r\n    ukrainian:`Приватні методи/змінні доступні лише зсередини класу. Захищені методи/змінні доступні зсередини класу та класу розширення.`\r\n  },\r\n  {\r\n    title:`how change detection works?`,\r\n    english:`Change detection works by detecting common browser events like mouse clicks, HTTP requests, and other types of events, and deciding if the view of each component needs to be updated or not.`,\r\n    ukrainian:`Виявлення змін працює, виявляючи типові події браузера, як-от клацання мишею, HTTP-запити та інші типи подій, і вирішуючи, чи потрібно оновлювати перегляд кожного компонента чи ні.`\r\n  },\r\n  {\r\n    title:`What are the types of change detection:`,\r\n    english:`default change detection: Angular decides if the view needs to be updated by comparing all the template expression values before and after the occurrence of an event, for all components of the component tree. OnPush change detection: this works by detecting if some new data has been explicitly pushed into the component, either via a component input or an Observable subscribed to using the async pipe`,\r\n    ukrainian:`виявлення змін за замовчуванням: Angular вирішує, чи потрібно оновлювати представлення, порівнюючи всі значення виразу шаблону до та після виникнення події для всіх компонентів дерева компонентів. Виявлення змін OnPush: це працює, виявляючи, чи деякі нові дані були явно вставлені в компонент, або через введення компонента, або через Observable, підписаний на асинхронний канал.`\r\n  },\r\n  {\r\n    title:`What is service worker?`,\r\n    english:`Adding a service worker to an Angular application is one of the steps for turning an application into a Progressive Web App (also known as a PWA). At its simplest, a service worker is a script that runs in the web browser and manages caching for an application. Service workers function as a network proxy.`,\r\n    ukrainian:`Додавання сервіс-воркера до програми Angular є одним із кроків для перетворення програми на прогресивний веб-додаток (також відомий як PWA). У найпростішому вигляді сервіс-воркер — це сценарій, який виконується у веб-браузері та керує кешуванням програми. Сервісні працівники функціонують як мережевий проксі.`\r\n  },\r\n  {\r\n    title:`What is angular ivy?`,\r\n    english:`ivy is an Angular compiler and rendering pipeline. Since version 9, Angular has replaced the View Engine compiler`,\r\n    ukrainian:`ivy - це компілятор і пайплайна візуалізації ангуляр. З 9 версії ангуляр замінив компілятор View Engine`\r\n  },\r\n  {\r\n    title: `What the difference between element and component?`,\r\n    english: `Angular elements are small blocks that describe what we want to see on the screen, in most cases they are not used directly, but are returned by components. And components are parts of the code that we can reuse, they return angular elements in order to show them on the screen`,\r\n    ukrainian:`ангуляр елементи це маленькі блоки які описують те що ми хочему побачити на екрані, в більшості вони не використовуються на пряму, а повертаються компонентами. А компоненти - це частини кода які ми можемо використовувати повторно, вони вертають ангуляр-елементи для того щоб показати їх на екрані`,\r\n  },\r\n  {\r\n    title: `What is Angular Reactive Form?`,\r\n    english: `Angular Reactive Form is a form building library for Angular that makes it easy to create reactive forms. A reactive form is one that automatically updates the form data when the underlying data changes. This can be useful for things like keeping a form synchronized with a database.`,\r\n    ukrainian: `Angular Reactive Form — це бібліотека створення форм для Angular, яка полегшує створення реактивних форм. Реактивна форма — це форма, яка автоматично оновлює дані форми, коли змінюються основні дані. Це може бути корисно для таких речей, як синхронізація форми з базою даних.`\r\n  },\r\n  {\r\n    title: `Can you explain the main difference between Template-Driven and Reactive Forms in Angular?`,\r\n    english: `The main difference between the two types of forms is that template-driven forms are more concerned with the structure of the form, while reactive forms are more concerned with the behavior of the form. With template-driven forms, you are responsible for creating the entire form in the template, including all of the input fields, validation, and submit handling. With reactive forms, on the other hand, you create the form in the component class, and then bind it to the template. This gives you more control over the form, but it can also be more difficult to set up.`,\r\n    ukrainian: `Основна відмінність між двома типами форм полягає в тому, що template-driven форми більше стурбовані структурою форми, тоді як реактивні форми більше стурбовані поведінкою форми. З template-driven формами ви відповідаєте за створення всієї форми в шаблоні, включаючи всі поля введення, перевірку та обробку надсилання. З іншого боку, з реактивними формами ви створюєте форму в класі компонентів, а потім прив’язуєте її до шаблону. Це дає вам більше контролю над формою, але її також може бути складніше налаштувати.`\r\n  },\r\n  {\r\n    title: `What are some advantages of using Reactive forms over template-driven forms?`,\r\n    english: `Reactive forms offer more flexibility and control over form validation. With template-driven forms, validation is typically done through directives, which can be difficult to control. Reactive forms also allow for more complex validation, such as cross-field validation.`,\r\n    ukrainian: `Реактивні форми пропонують більше гнучкості та контролю над перевіркою форми. У template-driven формах, перевірка зазвичай виконується за допомогою директив, якими може бути важко керувати. Реактивні форми також дозволяють виконувати більш складну перевірку, наприклад крос-філд перевірку.`\r\n  },\r\n  {\r\n    title: `What’s the best way to work with complex nested forms?`,\r\n    english: `There is no one-size-fits-all answer to this question, as the best way to work with complex nested forms will vary depending on the specific details of the form in question. However, some tips that may be helpful include breaking the form down into smaller manageable pieces, using formArray to manage groups of form controls, and using formGroupName to bind a form control to a specific form group.`,\r\n    ukrainian: `На це запитання немає однозначної відповіді, оскільки найкращий спосіб роботи зі складними вкладеними формами буде різним залежно від конкретних деталей відповідної форми. Однак деякі поради, які можуть бути корисними, включають розбиття форми на менші керовані частини, використання formArray для керування групами елементів керування форми та використання formGroupName для прив’язки елемента керування форми до певної групи форм.`\r\n  },\r\n  {\r\n    title: `Why would you use valueChanges() instead of statusChanges() for a reactive form control?`,\r\n    english: `ValueChanges will give you the current value of the control, while statusChanges will give you the validation status of the control.`,\r\n    ukrainian: `ValueChanges дасть вам поточне значення елемента керування, тоді як statusChanges дасть вам статус перевірки елемента керування.`\r\n  },\r\n  {\r\n    title: `What is the usage of the setValidators() method when used on a form control object in Angular?`,\r\n    english: `The setValidators() method is used to set the validators that will be used to validate the form control object. This is typically used when you want to add new validators to a form control object or when you want to change the existing validators that are being used.`,\r\n    ukrainian: `Метод setValidators() використовується для встановлення валідаторів, які використовуватимуться для перевірки об’єкта керування формою. Це зазвичай використовується, коли  треба додати нові валідатори до об’єкта керування формою або коли треба змінити існуючі валідатори, які вже використовуються.`\r\n  },\r\n  {\r\n    title: `What’s the role of the FormBuilder class in Angular?`,\r\n    english: `The FormBuilder class is responsible for creating and managing Angular forms. It provides a convenient way to create and manipulate form controls, as well as track and validate form values.`,\r\n    ukrainian: `Клас FormBuilder відповідає за створення та керування формами Angular. Він надає зручний спосіб створювати та маніпулювати елементами керування форми, а також відстежувати та перевіряти значення форми.`\r\n  },\r\n  {\r\n    title: `What is the purpose of the compose() method in Angular?`,\r\n    english: `The compose() method is used to create a higher-order observable, which is an observable that is composed of multiple other observables. This is often used when working with multiple streams of data that need to be processed together in some way.`,\r\n    ukrainian: `Метод compose() використовується для створення observable вищого порядку, який є  observable, що складається з кількох інших  observables. Це часто використовується під час роботи з кількома потоками даних, які певним чином потрібно обробляти разом.`\r\n  },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian: ``\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian: ``\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian: ``\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian: ``\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian: ``\r\n  // }\r\n] as Question[];\r\n//validators, lifecyclemethods, rxjs - methods, subjects\r\n","import {Question} from \"../question.interface\";\r\n\r\nexport const nodejsArray = [\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian:``,\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian:``,\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian:``,\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian:``,\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian:``,\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian:``,\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian:``,\r\n  // },\r\n  // {\r\n  //   title: ``,\r\n  //   english: ``,\r\n  //   ukrainian:``,\r\n  // }\r\n] as Question[]\r\n","import {Question} from \"../question.interface\";\r\n\r\nexport const  reactArray = [\r\n  {\r\n    title: `What is React?`,\r\n    english: `- React is a JavaScript library created by Facebook, - React is a User Interface (UI) library, - React is a tool for building UI components`,\r\n    ukrainian:`- React - це бібліотека JavaScript, створена Facebook, - React - це бібліотека інтерфейсу користувача (UI), - React - це інструмент для створення компонентів інтерфейсу користувача`,\r\n  },\r\n  {\r\n    title: `What is the main features of React?`,\r\n    english: `1. React is a single page application\r\n              2. React has jsx, which is convenient for quickly writing code\r\n              3. React has a ReactDom that speeds up the app\r\n              4. A component approach is applied (the code is easy to maintain and understand)\r\n              5. Easy to learn\r\n              6. Easily integrates with other libraries`,\r\n    ukrainian: `1. Реакт це single page application\r\n                2. В реакті є jsx, а це зручно для швидкого написання коду\r\n                3. Реакт має ReactDom, що пришвидшує роботу app\r\n                4. Застосовується компонентний підхід ( легко підтримувати код і розбиратись в ньому )\r\n                5. Легкий для вивчення\r\n                6. Легко інтегрується з іншими бібліотеками`,\r\n  },\r\n  {\r\n    title: `What is JSX?`,\r\n    english: `Jsx is a syntax in the JS - React library. JavaScript syntax extension. This syntax looks like a template language, but has all the language capabilities of JavaScript. In simple words, here we combine logic (just writing the code in js) and HTML + CSS`,\r\n    ukrainian:`Jsx це синтаксис у бібліотеці JS - React. розширення синтаксису JavaScript.  Цей синтаксис виглядає як мова шаблонів, але має всі мовні можливості JavaScript. Простими словами тут ми поєднуємо логіку(саме написання коду на js) та HTML + CSS`,\r\n  },\r\n  {\r\n    title: `Why react is not framework?`,\r\n    english: `First of all, I would like to note that the official website says that React is a library, not a framework. For a better understanding, you need to know the difference between a library and a framework. In short, a framework defines the architecture of an application and provides interaction between its components, and the library is a set of tools for solving a specific task, and the approach applies to one of the components, and not to the entire application. That is, the library does not define the structure of the application, and this is why React is more of a library than a framework. Although this is a very popular topic on the Internet, since React is often used in conjunction with other libraries that already allow building the structure of the program, which is more like a framework (`,\r\n    ukrainian:`Найперше зверну увагу, що на офіційному сайті сказано, React це бібліотека, не фреймворк. Для кращого розуміння треба знати різницю між бібліотекою та фреймворком. Якщо коротко, фреймворк  визначає архітектуру програми та забезпечує взаємодію між її компонентами, а бібліотека - це набір інструментів для вирішення конкретного завдання і підхід поширюється на один з компонентів, а не на весь додаток. Тобто бібліотека не визначає структуру програми, і ось чому React це більше бібліотека, а не фреймворк. Хоча це дуже холеварна тема в інтернеті, оскільки часто React застосовують у зв'язці з іншими бібліотеками, які уже дозволяють будувати структуру програми, що вже більше схоже на фреймворк (`,\r\n  },\r\n  {\r\n    title: `What the difference between element and component?`,\r\n    english: `React elements are small blocks that describe what we want to see on the screen, in most cases they are not used directly, but are returned by components. And components are parts of the code that we can reuse, they return react elements in order to show them on the screen`,\r\n    ukrainian:`Реакт елементи це маленькі блоки які описують те що ми хочему побачити на екрані, в більшості вони не використовуються на пряму, а повертаються компонентами. А компоненти - це частини кода які ми можемо використовувати повторно, вони вертають реакт-елементи для того щоб показати їх на екрані`,\r\n  },\r\n  {\r\n    title: `When to use a Class Component over a Function Component?`,\r\n    english: `If the component needs state or lifecycle methods then use class component otherwise use function component. However, from React 16.8 with the addition of Hooks, you could use state , lifecycle methods and other features that were only available in class component right in your function component`,\r\n    ukrainian:`Якщо компоненту потрібні методи стану або життєвого циклу, використовуйте компонент класу, інакше використовуйте компонент функції. Однак, починаючи з React 16.8 із додаванням хуків, ви можете використовувати стан, методи життєвого циклу та інші функції, які були доступні лише в компоненті класу, прямо у вашому функціональному компоненті`,\r\n  },\r\n  {\r\n    title: `What are Pure Components?`,\r\n    english: `Pure Components do not depend or modify the state of variables outside their scope. These are the building blocks of Functional Programming. Its return value is only determined by its input values. Its return value is always the same for the same input values. Pure components have some performance improvements and render optimizations since React implements the shouldComponentUpdate() method for them with a shallow comparison for props and state.`,\r\n    ukrainian:`Чисті компоненти не залежать і не змінюють стан змінних за межами своєї області. Це будівельні блоки функціонального програмування. Його значення, що повертається, визначається лише його вхідними значеннями. Його значення, що повертається, завжди однакове для однакових вхідних значень. Чисті компоненти мають деякі покращення продуктивності та оптимізацію візуалізації, оскільки React реалізує для них метод shouldComponentUpdate() із неглибоким порівнянням пропсів і стейту.`,\r\n  },\r\n  {\r\n    title: `What is state in React?`,\r\n    english: `The state object is where you store property values that belongs to the component. When the state object changes, the component re-renders.`,\r\n    ukrainian:`Об'єкт стейту – це місце, де ви зберігаєте значення властивостей, які належать компоненту. Коли об’єкт стейту змінюється, компонент ререндериться.`,\r\n  },\r\n  {\r\n    title: `What are props in React?`,\r\n    english: `Props in React are component properties, or in other words provide configuration values for the component. With the help of props, we can pass the necessary values to our child components.`,\r\n    ukrainian:`Props in React це властивості компонента, або іншими словами надають значення конфігурації для компонента. За допомогою props ми можемо передавати необхідні значення в наші child components.`,\r\n  },\r\n  {\r\n    title: `What is the difference between state and props?`,\r\n    english: `The difference is that state is private and can be changed from the component itself. Props are external and not controlled by the component itself. It is passed down from components, which also control the data. `,\r\n    ukrainian:`Різниця полягає в тому, що стан є приватним і може бути змінений із самого компонента. Пропси є зовнішніми і не контролюються самим компонентом. Він передається від компонентів, які також контролюють дані.`,\r\n  },\r\n  {\r\n    title: `Why should we not update the state directly?`,\r\n    english: `Because update state directly then it won't re-render the component.Because React keeps a copy of the previous state of the page. It uses it as a reference point when it decides on what should be repainted and what shouldn't.`,\r\n    ukrainian: `Якщо оновити стан безпосередньо, це не призведе до повторного рендерингу компонента. Оскільки React зберігає копію попереднього стану сторінки. Він використовує його як орієнтир, коли вирішує, що слід перефарбовувати, а що ні.`\r\n  },\r\n  {\r\n    title: `What is the purpose of callback function as an argument of setState()?`,\r\n    english: `The setState() method, which does not always update the component immediately, It can group or delay updates until next time. We can use componentDidUpdate() or the setState() callback (setState(updater, callback)), each of which is guaranteed to be called after an update has been applied`,\r\n    ukrainian: `Метод setState(), який не завжди оновлює компонент негайно, він може групувати або відкладати оновлення до наступного разу. Ми можемо використовувати компонентDidUpdate() або зворотний виклик setState() (setState(updater, callback)), кожен з яких гарантовано викликається після застосування оновлення`\r\n  },\r\n  {\r\n    title: `How to bind methods or event handlers in JSX callbacks?`,\r\n    english: `There are 3 possible ways to achieve this: - Binding in Constructor, - Public class fields syntax, -  Arrow functions in callbacks `,\r\n    ukrainian: `Є 3 можливі способи досягти цього: - байндінг в Конструкторі, - Public class fields syntax, - Функції стрілок у зворотних викликах`\r\n  },\r\n  {\r\n    title: `What are inline conditional expressions?`,\r\n    english: `First inline conditional expression is used as a short if-else statement - condition ? (condition is true) : (condition is false); Second inline conditional expression is boolean operator (Logical && operator) - (condition) && (If condition true that should be rendered)`,\r\n    ukrainian: `Перший вбудований умовний вираз використовується як короткий оператор if-else - умова ? (умова істинна) : (умова хибна); Другим вбудованим умовним виразом є логічний оператор (логічний оператор &&) - (умова) && (якщо умова істинна, її слід відобразити)`\r\n  },\r\n  {\r\n    title: `What is \"key\" prop and what is the benefit of using it in arrays of elements?`,\r\n    english: ` A key is a special string attribute you should include when creating arrays of elements. Key prop helps React identify which items have changed, are added, or are removed.`,\r\n    ukrainian: `атрибут key — це спеціальний атрибут, який має бути включений під час створення масивів елементів. Key prop допомагає React визначити, які елементи змінено, додано чи видалено.`\r\n  },\r\n  {\r\n    title: ` What is the use of refs?`,\r\n    english: `Refs returns a reference to the element.We can use it to: 1 Element focus, text selection. 2 Animations. 3 Integration with DOM libraries`,\r\n    ukrainian: `Refs повертає посилання на елемент. Ми можемо використовувати його для Фокусу елемента, виділення тексту. 2 Анімації. 3 Інтеграції з бібліотеками DOM`\r\n  },\r\n  {\r\n    title: `How to create refs?`,\r\n    english: `Refs are created with React.createRef() and attached to React elements via the ref attribute.  Typically, refs are assigned to a class instance property in the constructor so that they can be referenced from any part of the component.`,\r\n    ukrainian: `Рефи створюються за допомогою React.createRef() і приєднуються до елементів React через атрибут ref. Як правило, посилання призначаються властивості екземпляра класу в конструкторі, щоб на них можна було посилатися з будь-якої частини компонента.`\r\n  },\r\n  {\r\n    title: `What is Virtual DOM?`,\r\n    english: `The Virtual DOM (VDOM) is an in-memory representation of Real DOM. The representation of a UI is kept in memory and synced with the \"real\" DOM. It's a step that happens between the render function being called and the displaying of elements on the screen. This entire process is called reconciliation.`,\r\n    ukrainian: `Віртуальний DOM (VDOM) — це представлення реального DOM у пам’яті. Представлення інтерфейсу користувача зберігається в пам’яті та синхронізується з «реальним» DOM. Це крок, який відбувається між викликом функції рендерингу та відображенням елементів на екрані. Весь цей процес називається reconciliation.`\r\n  },\r\n  {\r\n    title: `How Virtual DOM works?`,\r\n    english: `Virtual DOM stored in memory and synchronized with the \"real\" DOM using a library such as ReactDOM.`,\r\n    ukrainian: `Віртуальний DOM зберігається в пам’яті та синхронізується з «реальним» DOM за допомогою бібліотеки, такої як ReactDOM.`\r\n  },\r\n  {\r\n    title: `What are forward refs?`,\r\n    english: `forward refs  are the feature that lets some components take a ref they receive, and pass it further down to a child.`,\r\n    ukrainian: `forward refs - це особливість, яка дозволяє деяким компонентам отримувати отримане посилання та передавати його дочірньому компонету.`\r\n  },\r\n  {\r\n    title: `What is the difference between Shadow DOM and Virtual DOM?`,\r\n    english: `The Shadow DOM is a browser technology designed primarily for scoping variables and CSS in web components. The Virtual DOM is a concept implemented by libraries in JavaScript on top of browser APIs.`,\r\n    ukrainian: `Shadow DOM — це технологія браузера, розроблена в основному для визначення змінних і CSS у веб-компонентах. Віртуальний DOM – це концепція, реалізована бібліотеками в JavaScript поверх API браузера.`\r\n  },\r\n  {\r\n    title: `What is React Fiber?`,\r\n    english: `React Fiber is an internal engine change that allows React to break the limits of the call stack`,\r\n    ukrainian: `React Fiber — це внутрішня зміна в реакті, яка дозволяє React порушувати обмеження кол стеку`\r\n  },\r\n  {\r\n    title: `What are the lifecycle methods of React?`,\r\n    english: `Each component in React has a lifecycle which you can monitor and manipulate during its three main phases.\r\n              The three phases are: Mounting, Updating, and Unmounting.\r\n              Mounting lifecycle methods:\r\n              1. constructor()\r\n              2. static getDerivedStateFromProps()\r\n              3. render()\r\n              4. componentDidMount()\r\n              Updating lifecycle methods:\r\n              1. static getDerivedStateFromProps()\r\n              2. shouldComponentUpdate()\r\n              3. render()\r\n              4. getSnapshotBeforeUpdate()\r\n              5. componentDidUpdate()\r\n              Unmounting lifecycle method:\r\n              componentWillUnmount`,\r\n    ukrainian: `Кожен компонент у React має життєвий цикл, який можна контролювати та маніпулювати ним протягом трьох основних фаз.`\r\n  },\r\n  {\r\n    title: `What are Higher-Order components?`,\r\n    english: `A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React's compositional nature. Concretely, a higher-order component is a function that takes a component and returns a new component.`,\r\n    ukrainian: `Компонент вищого порядку (HOC) — це вдосконалена техніка в React для повторного використання логіки компонента. HOC як такі не є частиною React API. Вони є шаблоном, який випливає з композиційної природи React. Конкретно, компонент вищого порядку — це функція, яка приймає компонент і повертає новий компонент.`\r\n  },\r\n  {\r\n    title: `What is context?`,\r\n    english: `A context provides a way to pass data through the component tree without having to manually pass props at each level.`,\r\n    ukrainian: `Контекст забезпечує спосіб передавати дані через дерево компонентів без необхідності передавати пропси вручну на кожному рівні.`\r\n  },\r\n  {\r\n    title: `What is children prop?`,\r\n    english: `Children prop is used to render the content which we passed to the component when it was invoked.`,\r\n    ukrainian: `Children prop використовується для відтворення вмісту, який ми передали компоненту під час його виклику.`\r\n  },\r\n  {\r\n    title: `Why fragments are better than container divs?`,\r\n    english: `Fragments are a bit faster and use less memory by not creating an extra DOM node. This only has a real benefit on very large and deep trees. Some CSS mechanisms like Flexbox and CSS Grid have a special parent-child relationships, and adding divs in the middle makes it hard to keep the desired layout.`,\r\n    ukrainian: `Фрагменти працюють трохи швидше та використовують менше пам’яті, оскільки не створюють додаткового вузла DOM. Це має реальну користь лише на дуже великих і глибоких деревах. Деякі механізми CSS, як-от Flexbox і CSS Grid, мають спеціальні батьківсько-начірні зв’язки, і додавання елементів div у середині ускладнює збереження потрібного макета.`\r\n  },\r\n  {\r\n    title: `What are portals in React?`,\r\n    english: `Portal is a recommended way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. ReactDOM.createPortal(child, container); The first argument is any render-able React child, such as an element, string, or fragment. The second argument is a DOM element.`,\r\n    ukrainian: `Портал — це рекомендований спосіб відтворення дочірніх елементів у вузлі DOM, який існує поза ієрархією DOM батьківського компонента. ReactDOM.createPortal(нащадок, контейнер); Перший аргумент — це будь-який дочірній елемент React, який можна візуалізувати, наприклад елемент, рядок або фрагмент. Другим аргументом є елемент DOM.`\r\n  },\r\n  {\r\n    title: `What are stateless components?`,\r\n    english: `Stateless components are those components which don't have any state at all, which means you can't use this. setState inside these components. It is like a normal function with no render method. It has no lifecycle, so it is not possible to use lifecycle methods such as componentDidMount and other hooks.`,\r\n    ukrainian: `стейтлесс компоненти — це ті компоненти, які взагалі не мають жодного стейту, що означає, що не можна використовувати setState всередині цих компонентів. Це як звичайна функція без методу ререндерингу. Він не має життєвого циклу, тому неможливо використовувати такі методи життєвого циклу, як componentDidMount та інші хуки.`\r\n  },\r\n  {\r\n    title: `What are fragments?`,\r\n    english: `React Fragments allow you to wrap or group multiple elements without adding an extra node to the DOM.`,\r\n    ukrainian: `Фрагменти React дозволяють обернути або згрупувати кілька елементів без додавання додаткового вузла до DOM.`\r\n  },\r\n  {\r\n    title: `What are stateful components?`,\r\n    english: `A stateful component is a component that holds some state`,\r\n    ukrainian: ` стейтфул Компонент — це компонент, який зберігає певний стейт`\r\n  },\r\n  {\r\n    title: `What is reconciliation?`,\r\n    english: `Reconciliation is the process through which React updates the DOM. When a component’s state changes, React has to calculate if it is necessary to update the DOM. It does this by creating a virtual DOM and comparing it with the current DOM. In this context, the virtual DOM will contain the new state of the component.`,\r\n    ukrainian: `Reconciliation - це процес, за допомогою якого React оновлює DOM. Коли стан компонента змінюється, React має розрахувати, чи потрібно оновлювати DOM. Це робиться шляхом створення віртуальної DOM і порівняння її з поточною DOM. У цьому контексті віртуальний DOM міститиме новий стан компонента.`\r\n  },\r\n  {\r\n    title: `How to set state with a dynamic key name?`,\r\n    english: `You can do this using a computed property name. For example: onClick={() => {\r\n             this.setState({\r\n               [this.state.name]: this.state.value,\r\n             });`,\r\n    ukrainian: `Це можна зробити за допомогою обчисленої назви властивості(приклад зверху)`\r\n  },\r\n  {\r\n    title: `Why React uses className over class attribute?`,\r\n    english: `class is a keyword in JavaScript, and JSX is an extension of JavaScript. That's the principal reason why React uses className instead of class.`,\r\n    ukrainian: `class — це ключове слово в JavaScript, а JSX — це розширення JavaScript. Це головна причина, чому React використовує className замість class.`\r\n  },\r\n  {\r\n    title: `How to apply validation on props in React?`,\r\n    english: `React JS has an inbuilt feature for validating props data type to make sure that values passed through props are valid. React components have a property called propTypes which is used to setup data type validation.`,\r\n    ukrainian: `React JS має вбудовану функцію для перевірки типу даних props, щоб переконатися, що значення, передані через props, є дійсними. Компоненти React мають властивість під назвою propTypes, яка використовується для налаштування перевірки типу даних.`\r\n  },\r\n  {\r\n    title: `What are the advantages of React?`,\r\n    english: `Virtual Document Object Model, the real DOM is updated only after interacting with the virtual DOM.\r\n              High performance;\r\n              Reapplying Components;\r\n              When working with ReactJS, you create reusable components: most often, a UI component can be used in other parts of the code or even in different projects with little to no changes.\r\n              Downstream data;\r\n              One-way data flow in React is another very useful feature. This flow of data is also called top-down or parent-to-child;\r\n              React Browser Tools;\r\n              React Developer Tools is a free extension for Chrome and Firefox that provides a whole set of validation widgets;`,\r\n    ukrainian: `Virtual Document Object Model, реальний DOM оновлюється лише після взаємодії з віртуальним DOM.\r\n                Висока працездатність;\r\n                Повторне застосування компонентів;\r\n                Працюючи з ReactJS, створюються багаторазові компоненти: найчастіше компонент інтерфейсу користувача можна використовувати в інших частинах коду або навіть у різних проектах практично без змін.\r\n                Односторонній потік даних у React є ще однією дуже корисною функцією. Цей потік даних також називається «зверху вниз» або «від батьків до дитини».\r\n                Інструменти браузера React такі як:\r\n                React Developer Tools це безкоштовне розширення для Chrome і Firefox, яке надає цілий набір віджетів перевірки;`\r\n  },\r\n  {\r\n    title: `What are the limitations of React?`,\r\n    english: `1. The high pace of development - The high pace of development has an advantage and disadvantage both. In case of disadvantage, since the environment continually changes so fast, some of the developers not feeling comfortable to relearn the new ways of doing things regularly. It may be hard for them to adopt all these changes with all the continuous updates. They need to be always updated with their skills and learn new ways of doing things.\r\n              2. Poor Documentation - It is another cons which are common for constantly updating technologies. React technologies updating and accelerating so fast that there is no time to make proper documentation. To overcome this, developers write instructions on their own with the evolving of new releases and tools in their current projects.\r\n              3. View Part - ReactJS Covers only the UI Layers of the app and nothing else. So you still need to choose some other technologies to get a complete tooling set for development in the project.\r\n              4. JSX as a barrier - ReactJS uses JSX. It's a syntax extension that allows HTML with JavaScript mixed together. This approach has its own benefits, but some members of the development community consider JSX as a barrier, especially for new developers. Developers complain about its complexity in the learning curve.`,\r\n    ukrainian: `1. Високі темпи розвитку - Високі темпи розвитку мають як переваги, так і недоліки. У разі недоліку, оскільки середовище постійно змінюється так швидко, деякі з розробників не відчувають себе комфортно регулярно вивчати нові способи роботи. Їм може бути важко прийняти всі ці зміни з усіма постійними оновленнями. Їм потрібно постійно оновлювати свої навички та вивчати нові способи роботи.\r\n                2. Погана документація - Це ще один недолік, який характерний для постійно оновлюваних технологій. Технології React оновлюються та прискорюються настільки швидко, що немає часу робити належну документацію. Щоб подолати це, розробники самостійно пишуть інструкції з розвитком нових випусків та інструментів у своїх поточних проектах.\r\n                3. Переглянути частину - ReactJS охоплює лише рівні інтерфейсу користувача програми і нічого більше. Тому вам все одно потрібно вибрати деякі інші технології, щоб отримати повний набір інструментів для розробки в проекті.\r\n                4. JSX як бар'єр - ReactJS використовує JSX. Це синтаксичне розширення, яке дозволяє змішувати HTML із JavaScript. Цей підхід має свої переваги, але деякі члени спільноти розробників вважають JSX перешкодою, особливо для нових розробників. Розробники скаржаться на його складність у кривій навчання.`\r\n  },\r\n  {\r\n    title: `How to use InnerHtml in React?`,\r\n    english: `The dangerouslySetInnerHTML attribute is React's replacement for using innerHTML in the browser DOM. Just like innerHTML, it is risky to use this attribute considering cross-site scripting (XSS) attacks. You just need to pass a __html object as key and HTML text as value.`,\r\n    ukrainian: `Атрибут dangerouslySetInnerHTML є заміною React для використання innerHTML у DOM браузера. Так само, як і innerHTML, використовувати цей атрибут ризиковано через атаки міжсайтового сценарію (XSS). Вам просто потрібно передати об’єкт __html як ключ і текст HTML як значення.`\r\n  },\r\n  {\r\n    title: `How are error boundaries handled in React v15?`,\r\n    english: `React v15 provided very basic support for error boundaries using unstable_handleError method. It has been renamed to componentDidCatch in React v16.`,\r\n    ukrainian: `React v15 забезпечив базову підтримку меж помилок за допомогою методу unstable_handleError. Його було перейменовано на componentDidCatch у React v16.`\r\n  },\r\n  {\r\n    title: `What will happen if you use props in initial state?`,\r\n    english: `If the props on the component are changed without the component being refreshed, the new prop value will never be displayed because the constructor function will never update the current state of the component. The initialization of state from props only runs when the component is first created.`,\r\n    ukrainian: `Якщо властивості компонента змінено без оновлення компонента, нове значення властивості ніколи не відображатиметься, оскільки функція конструктора ніколи не оновлюватиме поточний стан компонента. Ініціалізація стану з пропсів виконується лише під час першого створення компонента.`\r\n  },\r\n  {\r\n    title: `What is the impact of indexes as keys?`,\r\n    english: `React recommends that you do not use indexes as keys, since it could impact performance negatively and could lead to some unstable component behaviour. Using index might result in performance issues and data binding issues in case reordering in the form of sorting, filtering might happen.`,\r\n    ukrainian: `React рекомендує не використовувати індекси як ключі, оскільки це може негативно вплинути на продуктивність і призвести до нестабільної поведінки компонентів. Використання індексу може призвести до проблем із продуктивністю та зв’язуванням даних у разі зміни порядку у формі сортування, фільтрації.`\r\n  },\r\n  {\r\n    title: `What is the purpose of getDerivedStateFromProps() lifecycle method?`,\r\n    english: `The new static getDerivedStateFromProps() lifecycle method is invoked after a component is instantiated as well as before it is re-rendered. It can return an object to update state, or null to indicate that the new props do not require any state updates.`,\r\n    ukrainian: `Новий статичний метод життєвого циклу getDerivedStateFromProps() викликається після створення екземпляра компонента, а також перед його повторним відтворенням. Він може повернути об’єкт до стану оновлення або null, щоб вказати, що нові властивості не потребують оновлення стану.`\r\n  },\r\n  {\r\n    title: `How do you memoize a component?`,\r\n    english: `1.Since components are just functions though, they can be memoized using React. memo() . This prevents the component from re-rendering unless the dependencies (props) have changed.\r\n              2.In JSX, JavaScript expressions are written inside curly braces, and since JavaScript objects also use curly braces, the styling is written inside two sets of curly braces {{}}. style={{backgroundColor: \"red\"}}\r\n              3. The reason behind for this is that setState() is an asynchronous operation. React batches state changes for performance reasons, so the state may not change immediately after setState() is called.`,\r\n    ukrainian: `1. Оскільки компоненти — це лише функції, їх можна запам’ятати за допомогою React. memo() . Це запобігає повторному рендерингу компонента, якщо не змінилися залежності (реквізити).\r\n                2. У JSX вирази JavaScript записуються у фігурних дужках, а оскільки об’єкти JavaScript також використовують фігурні дужки, стиль записується у двох наборах фігурних дужок {{}}. style={{backgroundColor: \"red\"}}\r\n                3. Причиною цього є те, що setState() є асинхронною операцією. React пакетно змінює стан з міркувань продуктивності, тому стан може не змінитися одразу після виклику setState().`\r\n  },\r\n  {\r\n    title: `What is the purpose of getSnapshotBeforeUpdate() lifecycle method?`,\r\n    english: `getSnapshotBeforeUpdate() It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to componentDidUpdate() .`,\r\n    ukrainian: `getSnapshotBeforeUpdate() Він дозволяє компоненту отримувати деяку інформацію з DOM (наприклад, положення прокручування), перш ніж її потенційно змінити. Будь-яке значення, яке повертає цей метод життєвого циклу, буде передано як параметр componentDidUpdate().`\r\n  },\r\n  {\r\n    title: `What are error boundaries in React v16`,\r\n    english: `Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.`,\r\n    ukrainian: `Error boundaries — це компоненти React, які виловлюють помилки JavaScript будь-де у своєму дереві дочірніх компонентів, реєструють ці помилки та відображають резервний інтерфейс користувача замість дерева компонентів, яке вийшло з ладу. Error boundaries виявляють помилки під час візуалізації, у методах життєвого циклу та в конструкторах усього дерева під ними.`\r\n  },\r\n  {\r\n    title: `What will happen if you use setState in constructor?`,\r\n    english: `If we do this, React will also re-render the component and all its children. Therefore, in this case, you need to use this.setState`,\r\n    ukrainian: `Якщо ми це зробимо, React також повторно відрендерить компонент і всі його дочірні елементи. Тому в цьому випадку вам потрібно використовувати this.setState`\r\n  },\r\n  {\r\n    title: `What is the lifecycle methods order in mounting?`,\r\n    english: `Every component in React has to go through three phases that are Mounting, Updating, and Unmounting. These are called lifecycle methods in react.js. Out of the three, mounting is the first phase in the life cycle. There are four methods that fall under this phase those methods are: constructor() getDerivedStateFromProps() render() componentDidMount()`,\r\n    ukrainian: `Кожен компонент у React має пройти через три фази: монтування, оновлення та демонтування. Вони називаються методами життєвого циклу в react.js. З усіх трьох, монтаж є першим етапом життєвого циклу. Існує чотири методи, які підпадають під цю фазу: constructor() getDerivedStateFromProps() render() componentDidMount()`\r\n  },\r\n  {\r\n    title: `Why should component names start with capital letter?`,\r\n    english: `When an element type starts with a lowercase letter, it refers to a built-in component like <div> or <span> and results in a string <div> or <span> passed to React.createElement. Types that start with a capital letter like <Foo /> compile to React.createElement(Foo) and correspond to a component defined or imported in your JavaScript file.`,\r\n    ukrainian: `Коли тип елемента починається з малої літери, він посилається на вбудований компонент, наприклад <div> або <span>, і призводить до рядка <div> або <span>, який передається в React.createElement. Типи, які починаються з великої літери, наприклад <Foo />, компілюються до React.createElement(Foo) і відповідають компоненту, визначеному або імпортованому у вашому файлі JavaScript.`\r\n  },\r\n  {\r\n    title: `How to use React label element?`,\r\n    english: `If you try to render a <label> element bound to a text input using the standard for attribute, then it produces HTML missing that attribute and prints a warning to the console. Since for is a reserved keyword in JavaScript, use htmlFor instead`,\r\n    ukrainian: `Якщо ви спробуєте відобразити елемент <label>, прив’язаний до текстового введення за допомогою стандартного атрибута for, він створить HTML без цього атрибута та виведе попередження на консоль. Оскільки for є зарезервованим ключовим словом у JavaScript, замість нього використовуйте htmlFor.`\r\n  },\r\n  {\r\n    title: `What is the difference between setState and replaceState methods?`,\r\n    english: `With setState the current and previous states are merged. With replaceState, it throws out the current state, and replaces it with only what you provide.`,\r\n    ukrainian: `За допомогою setState поточний і попередній стани об’єднуються. За допомогою replaceState він викидає поточний стан і замінює його лише тим, що ти надаєш.`\r\n  },\r\n  {\r\n    title: `what is the difference between class and functional component?`,\r\n    english: `A FUNCTIONAL COMPONENT is just a plain JavaScript pure function that accepts props as an argument and returns a React element(JSX). There is no render method used in functional components. React lifecycle methods (for example, componentDidMount) cannot be used in functional components. Hooks can be easily used in functional components to make them Stateful. A CLASS COMPONENT requires you to extend from React. Component and create a render function which returns a React element. It must have the render() method returning JSX (which is syntactically similar to HTML). React lifecycle methods can be used inside class components (for example, componentDidMount). It requires different syntax inside a class component to implement hooks.`,\r\n    ukrainian: `ФУНКЦІОНАЛЬНИЙ КОМПОНЕНТ — це звичайна чиста функція JavaScript, яка приймає властивості як аргумент і повертає елемент React (JSX). У функціональних компонентах не використовується метод рендер. Методи життєвого циклу React (наприклад, componentDidMount) не можна використовувати у функціональних компонентах. Хуки можна легко використовувати у функціональних компонентах, щоб зробити їх Stateful. КОМПОНЕНТ КЛАСУ вимагає розширення з React. класовий компонент повинен мати метод render(), який повертає JSX (який синтаксично схожий на HTML). Методи життєвого циклу React можна використовувати всередині компонентів класу (наприклад, componentDidMount). Це вимагає іншого синтаксису всередині компонента класу для реалізації хуків.`\r\n  },\r\n  {\r\n    title: `what are the benefits of react hooks?`,\r\n    english: `By the hooks we got Improving Readability of Component Tree. The \"useContext\" hook has been a blessing for greatly improving the readability of JSX as it allows context values to be read outside of JSX. This was also previously possible in class components by using the static \"contextType\" property but is even cleaner with \"useContext\". Aside from the code being easier to read it is also much easier to read the component tree in the React dev tools when debugging. The value of this really adds up for components that previously used multiple nested contexts. Encapsulating Side Effects - \"useEffect\" solves this problem by handling both the setup and teardown of side effects. It does so by allowing the effect function to return a function to teardown the effect. Custom hooks are considerably a great mechanism for sharing logic across various components. A custom hook is simply a function that uses one or more React hooks and it can be called within a functional component, just like a standard hook.`,\r\n    ukrainian: `За допомогою хуків ми отримали покращення читабельності дерева компонентів. Хук «useContext» був благословенням для значного покращення читабельності JSX, оскільки він дозволяє зчитувати контекстні значення за межами JSX. Раніше це також було можливо в компонентах класу за допомогою статичної властивості \"contextType\", але ще чистіше з \"useContext\". Окрім легшого читання коду, також набагато легше читати дерево компонентів в інструментах розробника React під час налагодження. Цінність цього дійсно збільшується для компонентів, які раніше використовували кілька вкладених контекстів. - Інкапсуляція побічних ефектів - \"useEffect\" вирішує цю проблему, обробляючи як налаштування, так і демонтаж побічних ефектів. Це робиться, дозволяючи функції ефекту повертати функцію для зняття ефекту. - Користувальницькі хуки є чудовим механізмом для обміну логікою між різними компонентами. Спеціальний хук — це просто функція, яка використовує один або кілька хуків React, і її можна викликати у функціональному компоненті, як і стандартний хук.`\r\n  },\r\n  {\r\n    title: `what is conditional rendering? how to execute them?`,\r\n    english: `Conditional rendering is the ability to render markup elements or components based on an input condition. In other words, this is a kind of if else condition that helps to draw different options of the interface. Conditional rendering is specified inside the render method, And due to the fact that jsx does not support the conditional construction if else, it can be executed in two ways 1) double ampersand; 2) Ternary operator`,\r\n    ukrainian: `Умовний рендеринг - це можливість відмальовування елементів розмітки чи компонент на основі вхідної умови. Іншими словами це своєрідна if else умова, яка допомагає відмалювати різні варіанти інтерфейсу. Вказується умовний рендеринг всередині метода render, І через те що jsx не підтримує умовну конструкцію if else, Виконати можна двома варіантами 1)подвійний амперсант 2)Тернарний оператор`\r\n  },\r\n  {\r\n    title: `What is a switch component?`,\r\n    english: `This is a component that renders one of several components. This is a kind of react pattern that allows you to implement a convenient mechanism for drawing several components based on some condition. The main idea is a structure in the form of an object that contains keys and their corresponding components, receiving the props of the component, the switch gets the value of the key, after which, based on this value, it returns the desired component, to which all props are transferred thanks to the spread operator`,\r\n    ukrainian: `Це компонент який рендерить один з декількох компонентів. Це своєрідний react pattern, який дозволяє реалізувати зручний механізм відмалювання декількох компонент на основі якоїсь умови. Основна ідея це структура у вигляді обєкту, який містить ключі і відповідні їм компоненти, отримуючи пропси компонент перемикач дістає значення ключа, після чого по цьому значенню повертає потрібний компонент, якому завдяки спред оператора передаються всі пропси`\r\n  },\r\n  {\r\n    title: `the difference beetween react and reactDOM`,\r\n    english: `The react library contains functions that are related to elements and components, in fact, these are universal elements designed specifically for creating components. React dom is a library that provides browser-specific methods that can be used at the top level of the application to effectively manage the dom elements that are present on the page. It has such methods as render, find dom node, gidrate, create portal, and so on. From the very beginning, these two libraries were together, but to ensure rendering in different environments, the react team split the main react package from version 0.14 into two independent parts, react and react dom. Now it makes it possible to use and create components that can be used both in react and in react native`,\r\n    ukrainian: `Бібліотека react містить функції які повязані з елементами та компонентами, по суті це універсальні елементи призначені іменно для створення компонент. Reaсt dom - це бібліотека яка надає спеціальні для браузера методи які можуть бути використані на верхньому рівні додатку для ефективного керування дом елементами, які присутні на сторінці. У ньому є такі методи як render, find dom node, gidrate, create portal, і так далі. З самого початку дві цих бібліотеки були разом, проте задля забезпечення рендерингу в різних середовищах команда react розділила основний пакет react з версії 0.14, на дві незалежні частини react and react dom. Тепер це дає можливість використовувати та створювати компоненти які можуть використовуватись як в react так і в react native`\r\n  },\r\n  {\r\n    title: `How does react handle or restrict the use of props of a certain type?`,\r\n    english: `We are talking about prop types - this is one of the options for catching errors related to incorrect types of props, thanks to the keyword isRequared. It allows you to mark props as mandatory, and the component, thanks to default props, defines their default values. Prop types defines the type of props, every time a certain value is passed through props, it is checked for the correct type, if an incorrect type is found, an error message will be thrown in the console. This ensures that the props will receive data with the correct types. Typescript or flow can also be analogues of the check`,\r\n    ukrainian: `Мова йде за prop types  - це один з варіантів відловлення помилок повязаних з неправильними типами пропсів, завдяки ключовому слові isRequared. Він дозволяє помічати пропси як обовязкові, а компонент завдяки default props, визначаэ їх значення за замовчуванням. Prop types визначаэ тип пропсів, кожного разу коли через props передається певне значення, він перевіряється на правильний тип, якщо буде знайдено неправильний тип в консолі буде викинуто повідомлення про помилку. Це гарантує що пропси будуть отримувати дані з вірними типами. Також аналогами перевірки може бути typescript or flow`\r\n  },\r\n  {\r\n    title: `What is strict mode in react? its advantages?`,\r\n    english: `Strict mode is a tool for identifying potential problems with the application, just like the strict mode fragment does not render anything, it defines additional checks and checks for child components, these checks only happen in developer mode or in development mode, they also do not affect the production build. Advantages of a strict regime: - Warning about using the deprecated stringRef string api; - Warning about using the outdated findDomNode method; - Identification of components with dangerous life cycle methods; - determination of unexpected side effects; - Determination of the use of the outdated api context;`,\r\n    ukrainian: `Strict mode - це інструмент для визначення потенційних проблем додатку, як і фрагмент strict mode нічого не рендерить, він визначає додаткові перевірки та перевірки для дочірних компонентів, ці перевірки відбуваються тільки в developer mode або в режимі розробки, також вони не впливають на production збірку. Переваги строгого режиму: - Попередження про використання застарілого api стрічкових силок stringRef; - Попередження про використання застарілого метода findDomNode; - визначення компонент з небезпечними методами життєвого циклу; - визначення неочікуваних побічних ефектів; - Визначення використання застарілого api context;`\r\n  },\r\n  {\r\n    title: `What is props drilling, how to avoid it?`,\r\n    english: `In react props are passed in one direction from top to bottom, from parent to child, If there is a small number of props or descendants - this is not a problem, but when developing an application in order to transfer props from the upper level, which are, for example, at the third level of nesting, it is necessary to transfer the same props to each component tree, the situation can also become complicated due to the fact that you need to throw several properties at once, and thus the number of props to the top-level component can be huge. this mechanism, or even an anti-pattern, is called prop-drilling. In order to avoid it, there are two approaches: -  Using redux store or any other state manager; -  Use the context and the useContext hook;`,\r\n    ukrainian: `В react props передаються в одному напрямку зверху в низ, від батьківського до дочірнього. При наявності незначної кількості пропсів або потомків - це не є проблемою, проте при розвитку додатку для того щоб передати пропси з верхнього рівня, які до прикладу знаходятся на третьому рівні вкладеності приходиться передавати одні і ті самі пропси в кожне дерево компонента, також ситуація може ускладнитись тим що прокидувати потрібно зразу декілька властивостей, і таким чином кількість пропсів у компонент верхнього рівня може бути величезною. даний механізм, чи навіть антипатерн називається prop-drilling. Для того щоб його уникнути є два підходи - Використання redux store, або будь-якого іншого state менеджера; - Використати контекст та хуком useContext;`\r\n  },\r\n  {\r\n    title: `what is polling? how to implement it in react?`,\r\n    english: `The polling mechanism is a common approach for regular asynchronous requests. For example, we have a component and a server in which we send a request to receive data, so as not to block the client's work with the server or the application, asynchronous requests can be delayed or in the background. In this way, you can configure service requests after a certain time interval. In React, such a mechanism is implemented thanks to setInterval and the useEffect hook. When the component is rendered for the first time, a timer is started, which makes a request to the server every second. To stop this timer when dismounting the component, useEffect returns the clearInterval method. In addition, you can add a condition for receiving data to such a method, which will help stop the request timer even before disassembling the component`,\r\n    ukrainian: `Механізм polling - це поширений підхід для регулярних асинхронних запитів. Наприклад у нас є компонент та сервер у якому надсилаємо запит на отримання даних, щоб не блокувати роботу клієнта з сервером чи додатком, асинхронні запити можуть відбуватись або відкладено, або в фоновому режимі. Таким чином можна налагодити запити сервісів через певний інтервал часу. В реакт такий механізм реалізовується завдяки setInterval та хука useEffect. При першому рендері компонента запускається таймер, який кожну секунду робить запит на сервер. Щоб зупинити цей таймер при розмонтовуванні компонента в useEffect повертається метод clearInterval. Додатково в такий метод можна і додати умову отримання даних, що допоможе зупинити таймер запитів ще до розмонтування компонента`\r\n  },\r\n  {\r\n    title: `what is react dom server?`,\r\n    english: `The react dom server object allows you to render components in the form of static markup, usually these types of markup are used on node servers. Ssr is a technique that allows you to draw client one-page applications on the server and send them to the client in the form of ready-made markup - it makes dynamic components static. the advantages are that: - it increases the page rendering speed, which increases the UX; - it improves search engine optimization or SEO by simplifying the indexing of pages by search engines; - it increases the availability of metadata, header images, which allows users to easily share the content of the application;`,\r\n    ukrainian: `Об'єкт react dom server дозволяє рендерити компоненти у вигляді статичної розмітки, зазвичай такі типи розмітки використовуються на нод серверах. Ssr - це техніка яка дозволяє відмальовувати клієнтські односторінкові додатки на сервері  та відправляти їх клієнту у вигляді готової розмітки - це робить динамічні компоненти статичними. плюсами є те що: -  це збільшує швидкість рендеру сторінок, що збільшує UX;  -  це покращує пошукову оптимізацію або SEO, спрощуючи індексацію сторінок пошуковими роботами; - це збільшує доступність метаданих, зображень заголовків, що дозволяє користувачам легко ділитись контентом додатку;`\r\n  },\r\n  {\r\n    title: `what is lazy function in react?`,\r\n    english: `It is worth noting that this is a method from the react suspense api. React lazy or lazy function is a function that allows you to create components that are loaded thanks to dynamic import and that are rendered as normal components. This allows you to reduce the size of the bundle, since then only those components that are actually drawn on the ui at the moment are loaded. React lazy accepts a function as an argument, this function returns a promise as a result of calling import to load the component`,\r\n    ukrainian: `Варто відмітити що це метод з api react suspense. React lazy або лінива функція - це функція яка дозволяє створювати компоненти, які завантажуються завдяки динамічному імпорту та які рендеряться як звичайні компоненти. Це дозволяє зменшити розмір bundle, так як тоді завантажуються лише ті компоненти які реально відмальовуються на ui в наявний момент. React lazy в якості аргументу приймає функцію, ця функція повертає проміс, в результаті виклику імпорту для завантаження компонента `\r\n  },\r\n  {\r\n    title: `what is the difference between mounting and rendering`,\r\n    english: `Rendering is a function, or render method, that is called by a component and returns instructions for creating a dom. the render method is called every time the component is rendered. A component is updated when its state or props change. Montage is the first rendering of the component and construction of the initial model of the document. Mounting a component means embedding the elements it creates in the browser home. The second and subsequent renderings are repeated calls to the function to obtain information about the already mounted component.`,\r\n    ukrainian: `Рендерінг -  це функція, або метод render, який  викликається компонентом і повертаює інструкції для створення дом. метод рендер викликається при кожному рендері компонента. Оновлення компонента  відбувається при зміні його стану, або пропсів. Монтування - це перший рендер компонента та побудови початкової моделі документа. Монтування компонента означає вбудовування створюваних ним елементів в браузерний дом. Другий і подальші рендеринги - це повторний виклик функції для отримання інформації про вже змонтований компонент. `\r\n  },\r\n  {\r\n    title: `what is pointer events?`,\r\n    english: `pointer events are an important part of user interaction on the Internet. In React, the PointerEvent interface provides a way to handle mouse or touchscreen events. The PointerEvent interface contains several properties and methods for handling pointer events. Some of the most commonly used pointer events in React include onPointerDown, onPointerMove, and onPointerUp. These events are fired when the user begins to click and hold the mouse or sensor, move it, or release it, respectively. React also supports a number of other events to handle advanced interactions with the mouse or sensor`,\r\n    ukrainian: `pointer events є важливою частиною взаємодії користувача в Інтернеті. У React інтерфейс PointerEvent забезпечує спосіб обробки подій,для миші або сенсорного екрану. Інтерфейс PointerEvent містить кілька властивостей і методів для обробки pointer events. Деякі з найбільш часто використовуваних pointer events в React включають onPointerDown, onPointerMove і onPointerUp. Ці події запускаються, коли користувач починає натискати й утримувати мишу або сенсор, переміщує їх або відпускає відповідно.React також підтримує низку інших подій для обробки розширених взаємодій з мишею або сенсором`\r\n  },\r\n  {\r\n    title: `what is inheritance inversion?`,\r\n    english: `An inheritance inversion is a hoc (higher-order component) that returns a class that extends the wrapped component`,\r\n    ukrainian: `Інверсія наслідування - це hoc (компонент вищого порядку) в ньому повертається клас який розширює обгорнутий компонент`\r\n  },\r\n  {\r\n    title: `How to implement two-way data binding in React?`,\r\n    english: `you can perform such a connection thanks to setState in the class component and useState in the functional one, as well as the handler that is added to the input element, so the data entered on the ui gets into the state and updates it, and updating the state in turn causes updates on the ui`,\r\n    ukrainian: `виконати таку звязку можна завдяки setState в класовому компоненті та useState в функціональному, і також обробника який добавляється на input елемент, таким чином дані які вводяться на ui попадають в state і оновлюють його, а оновлення стейту в свою чергу викликають оновлення на ui`\r\n  },\r\n  {\r\n    title: `difference between useEffect and componentDidMount()?`,\r\n    english: `componentDidMount та useEffect - запускаються одразу після монтування компоненти, тим не менш useEffect викликається після відоображення на екрані результатів рендерингу, а це означає що ми можемо отримати мигання, або так званий flicker  у випадку коли необхідно прочитати дом і синхронно оновити стан для отримання нового ui. Інший хук який називається useLayoutEffect , був спроектований спеціально для таких випадків. Він відоображається на екрані перед відоображення результатів рендеренгу, тому useLayoutEffect ближче до componentDidUpdate по часі виконання ніж useEffect `,\r\n    ukrainian: `componentDidMount and useEffect - run immediately after mounting the component, however, useEffect is called after the rendering results are displayed on the screen, which means that we can get a flicker, or the so-called flicker in the case when it is necessary to read the home and synchronously update the state to get a new ui. Another hook called useLayoutEffect was designed specifically for such cases. It is displayed on the screen before rendering results, so useLayoutEffect is closer to componentDidUpdate in runtime than useEffect`\r\n  },\r\n  {\r\n    title: `what the Rules (restrictions) for the use of hooks?`,\r\n    english: `You should use hooks at the very top of the function hierarchy, that is, it means that you cannot call hooks in conditions or loops, since React cannot guarantee the order of their execution. You can call hooks only in functions or in function components or in custom hooks. The use of hooks in class components is not allowed`,\r\n    ukrainian: `Використовувати хуки варто в самому верху ієрархії функції, тобто це означає, що неможна викликати хуки в умовах чи циклах, так як реакт не може гарантувати порядок їх виконання. Викликати хуки можна лише в функціях або в функціональних компонентах, або в користувацьких хуках. Використання хуків в класових компонентах не допускається `\r\n  },\r\n  {\r\n    title: `what is lifting state up?`,\r\n    english:`Lifting state up is a pattern thanks to which one state can be used for several components at once. Usually, some components must react to the same events or state changes, so it is necessary to somehow notify all components when something has changed, the recommended option to do this is to raise the state to the top, this means that the common state must be raised to the common ancestor`,\r\n    ukrainian:`Lifting state up - це паттерн завдяки якому один стан може бути використаний зразу для декількох компонент. Зазвичай деякі компоненти мають реагувати на одні і ті самі події, або зміну стану, тому необхідно якимось чином повідомляти всі компоненти коли щось змінилось, рекомендуючий варіант це зробити - це підняти стан в верх, це означає що спільний стан має бути піднятий до спільного предка `,\r\n  },\r\n  {\r\n    title: `what shouldComponentUpdate do?`,\r\n    english:`In the life cycle of class components, there is a shouldComponentUpdate method, which allows you to refuse to participate in the process of comparing some components and their child elements, the purpose of the comparison is to update the interface based on the new state in the most efficient way. Therefore, if we know that part of the interface will not change, then it makes no sense to force React to run the update check on its own. It is for such cases that shouldComponentUpdate is used, which returns a boolean value. If false is returned from this method, react will understand that the existing component and all its child components will remain the same as they were, and the reconciliation mechanism will not be triggered, which in some cases will speed up performance. An analogue of shouldComponentUpdate is the useEffect hook, which accepts as dependencies the arguments on which component re-rendering depends`,\r\n    ukrainian:`В життєвому циклі класових компонентів є метод shouldComponentUpdate, який дає можливість відмовитись від участі в процесі порівняння деяких компонентів та їх дочірних елементів, ціль порівняння полягає в тому щоб найефективнішим шляхом оновити інтерфейс на основі нового стану. Тому якщо ми знаємо, що частина інтерфейсу не зміниться то немає сенсу заставляти реакт проганяти перевірку оновлення самостійно. Саме для таких випадків використовується shouldComponentUpdate, який повертає булеве значення. При поверненні false з цього методу, react буде розуміти що наявний компонент і всі його дочірні компоненти залишаться таким самими як і були, при цьому мезанізм узгодження не буде запущений, що в деяких випадках пришвидшить продуктивність. Аналогом shouldComponentUpdate є хук useEffect, який приймає в якості залежностей аргументи від якого залежить ререндеринг компонента`,\r\n  },\r\n  {\r\n    title: `difference between createElement and CloneElement?`,\r\n    english:`The cloneElement function, as the name implies, returns a copy of the specified element. additional props or child elements can be passed to this function. cloneElement can be used when a child element wants to add or change a property of its child elements. As for createElement, this function is used to create and return a new react element of the specified type. The type argument can be a tag name string, such as 'div' or 'span', or a react component, class or function type, or a react fragment type. The jsx code will be converted for use in react.`,\r\n    ukrainian:`Функція cloneElement, як зрозуміло з назви повертає копію вказаного елементу. в цю функцію можна передати додаткові пропси, або дочірні елементи. cloneElement можна використовувати коли дочірний елемент хоче додати або змінити властивість своїх дочірніх елементів. Що стосується createElement то дана функція використовується для створення та повернення нового react елемента заданого типу. Аргумент типу може бути стрінгою імені тега, наприклад ‘div’ or ‘span’, а також типом react component, class or function або типом react fragment. Код jsx буде перетворений для використання в react.`,\r\n  },\r\n  {\r\n    title: `what is useReducer?`,\r\n    english:`useReducer is a hook that takes a reducer function and the initial state of the application as arguments. Returns the current state and dispatcher for dispatching operations. Although useState is a basic hook and useReducer is an advanced one. useState is implemented thanks to useReducer, which means that useReducer is a primitive that can be used in all cases of using useState. The mechanism of operation is as follows. First, the initial state and reducer are determined. They are passed to the useReducer hook. This hook returns the current state value and the dispatcher used to update the state. When the user clicks on the button, a certain operation is sent to the reducer, which updates the counter based on the operation. In this way, you can define as many operations as the application needs.`,\r\n    ukrainian:`useReducer - це хук, який приймає функію reducer, та початковий стейт додатку в якості аргументів. Повертає наявний стан та діспатчер для відправки операцій.Незважаючи на те, що useState - базовий хук, а useReducer - просунутий. useState реалізований завдяки useReducer, а це означає що useReducer  - це примітив який може використовуватись у всіх випадках використання useState.Механізм роботи наступний: Спочатку визначається інішіал стейт та reducer. Вони передаються в хук useReducer. Цей хук повертає наявне значення стану та діспатчер, який використовується для оновлення стейту. Коли користувач натискає на кнопку то відбувається відправка певної операції в редюсер, який оновлює лічильник на основі операції. Таким чином можна визначати стільки операцій скільки потрібно додатку.`,\r\n  },\r\n  {\r\n    title: `what is useCallback?`,\r\n    english:`Хук React useCallback повертає мемоїзовану функцію зворотного виклику. Запам'ятовування робить кешування значенням, щоб його не потрібно було перевизначати. Це дозволяє нам ізолювати ресурсомісткі функції, щоб вони не запускалися автоматично при кожному рендері. Хук useCallback запускається лише тоді, коли оновлюється одна з його залежностей. Це покращує продуктивність.`,\r\n    ukrainian:`The React useCallback hook returns a memoized callback function. Remembering makes caching a value so that it doesn't need to be overridden. This allows us to isolate resource-intensive functions so they don't run automatically on every render. The useCallback hook only fires when one of its dependencies is updated. This improves performance.`,\r\n  },\r\n  {\r\n    title: `what is useMemo?`,\r\n    english:`useMemo() hook - can be used to optimize calculations that happen in functional components, useMemo is similar to useCallback except that it takes any value, not just functions, basically it takes a function that returns a value and an array of dependencies, the value returned by the function. It is redefined only when dependencies change`,\r\n    ukrainian:`Хук useMemo() - може використовуватись для оптимізації вичислень, які відбуваються в функціональних компонентах, useMemo схожий на useCallback за винятком того що він приймає будь-яке значення, а не лише функції, в основному він приймає функцію яка повертає значення, та масив залежностей, значення яке повертається функцією. Визначається повторно тільки при зміні залежностей `,\r\n  },\r\n  {\r\n    title: `what is useImperativeHandle?`,\r\n    english:`The useImperativeHandle hook - allows you to customize the value that is passed to the parent component thanks to the ref. useImperativeHandle should be used in compatibility with forwardRef`,\r\n    ukrainian:`Хук useImperativeHandle - дозволяє кастомізувати значення, яке передається батьківському компоненту завдяки ref. useImperativeHandle  має використовуватись в сумісності з forwardRef`,\r\n  },\r\n  {\r\n    title: `what is useLayoutEffect?`,\r\n    english:`useLayoutEffect is a hook that runs after all dom manipulations are done, but before the browser renders it. This may be useful for obtaining additional information from the dom. For example, to get the amount of scrolling, or element styles and use this information to adjust the dom. Also to trigger a re-render by changing its state. This hook is designed to perform those tasks performed by such methods as componentDidMount and componentDidUpdate.`,\r\n    ukrainian:`useLayoutEffect - це хук, що запускається після виконання всіх маніпуляцій з dom, проте до його відмалювання браузером. Це може бути корисним для отримання додаткової інформації з дом. Наприклад для отримання величини прокрутки, або стилів елемента та використання цієї інформації для корегування дом. Також для запуску повторного рендеру шляхом зміни його стану. Даний хук призначений для виконання тих задач які виконують такі методи як componentDidMount and componentDidUpdate.`,\r\n  },\r\n  {\r\n    title: `How to draw html code in react component?`,\r\n    english:`For this, react has a special attribute dangerouslySetInnerHTML, it is essentially an alternative to innerHTML. It represents a cross-site scripting or xss threat. Hence the prefix dangerously at the beginning. As an argument, it accepts an object with the __html key and html as a value, after which this markup will be drawn on the page.`,\r\n    ukrainian:`Для цього в react є спеціальний атрибут dangerouslySetInnerHTML, він по суті є альтернативою innerHTML. Він являє собою небезпеку міжсайтового скриптингу або xss. Звідси і приставка dangerously на початку. В якості аргументу він приймає об\\`єкт з ключом __html та html в якості значення, після чого ця розмітка буде відмальована на сторінці.`,\r\n  },\r\n  {\r\n    title: `Why do you need to pass a function to setState()?`,\r\n    english:`The fact is that setState is an asynchronous operation, react postpones updating the state for performance reasons. Therefore, the state may not be updated immediately after calling setState, which means that there is no need to rely on the existing state when calling setState. since one cannot be sure of what it is. The solution to this problem is to pass the callback function with the previous state as an argument. This makes it possible to avoid problems related to getting the old state due to the asynchronous nature of setState()`,\r\n    ukrainian:`Справа в тому, що setState - це асинхронна операція, react відкладає оновлення стану з причин продуктивності. Тому стан може оновитись не зразу після виклику setState, а це означає що не потрібно покладатись на наявний стейт при виклику setState. так як не можна бути впевненим в тому яким  він є.  Рішенням цієї проблеми є передача колбек функції з попереднім стейтом в якості аргументу. Це дає можливість уникнути проблем повязаних з отриманням старого стейту через асинхронну природу setState()`,\r\n  },\r\n  {\r\n    title: `What is the registerServiceWorker() method in react for?`,\r\n    english:`This method is integrated into create-react-app by default. React creates a worker service with no configuration by default. The worker service is a web API that allows you to write application files to the cache and return it when there is no network connection or a slow connection, which in turn greatly improves the user experience`,\r\n    ukrainian:`Цей метод за замовчуванням інтегрований в create-react-app. React створює сервіс воркер без налаштування по замовчуванням. Сервіс воркер це web API, яке дозволяє записувати файли додатків в кеш і повертати його при відсутності підключення до мережі чи повільному з' єднанні, що в свою чергу чудово покращує користувацький досвід.`,\r\n  },\r\n  {\r\n    title: `How does reactRouter differ from regular routing?`,\r\n    english:`There is only one html file in React - it is index.html. When the user moves to a new address, instead of receiving data from the server, the router returns one or another component. The user gets the impression that he is moving between different pages. In fact, application components are simply different visualizations of the same page. Under the hood, the router looks in the history of each component and, if there are changes in the history, the component is re-rendered. Before react router v4, the history value had to be set manually, but starting with react v4, most of the work related to routing is done automatically on the client side thanks to the browserRouter component`,\r\n    ukrainian:`В реакт існує лише один html файл - це index.html. Коли користувач переходить за новою адресою, замість отримання даних від сервера роутер повертає той або інший компонент. В користувача створюється враження, що він переміщується між різними сторінками. Та насправді компоненти додатку є просто різними візуалізаціями однієї сторінки. Під капотом router підглядує в history кожного компонента та при наявності змін в історії компонент ререндериться.  До react router v4 значення history треба було встановлювати вручну, проте починаючи з react v4 більша частина роботи повязаної з маршрутизацією автоматично виконується на стороні клієнту завдяки компоненту browserRouter `,\r\n  },\r\n  {\r\n    title: `What hooks were added to react router v5?`,\r\n    english:`Starting with version 5 of react router, following the library, react began to support hooks. As a result of its implementation, such hooks as useHistory, useLocation, UseParams, useRouteMatch appeared.`,\r\n    ukrainian:`Починаючи з 5 версії react router слідом за бібліотекою реакт став підтримувати хуки. В результаті його реалізації з'явились такі хуки як useHistory, useLocation, UseParams,  useRouteMatch.`,\r\n  },\r\n  {\r\n    title: `what is useHistory?`,\r\n    english:` Its a hook from react router. useHistory gives access to the history prop in react router, refers to the history dependency used by the router. The main value is in software routing thanks to such methods as push, replace and so on.`,\r\n    ukrainian:`це хук з react router. useHistory дає доступ до пропсу history в react router, посилається на залежність history, яка використовується роутером. Основне значення полягає в програмному роутингу завдяки таким методам як push, replace і так далі.`,\r\n  },\r\n  {\r\n    title: `what is useLocation?`,\r\n    english:`This is a hook from react router. useLocation - provides access to the location props. Similar to window location, but available anywhere, as it is a representation of the state and location of the router.`,\r\n    ukrainian:`Це хук з react router. useLocation - надає доступ до пропсу location. Схожий на window location, проте доступний в любому місці, оскільки є представленням стейту та локації роутера.`,\r\n  },\r\n  {\r\n    title: `what is useParams?`,\r\n    english:`This is a react router hook that provides access to the search bar options in the url.`,\r\n    ukrainian:`Це хук з react router, що надає доступ до параметрів пошукової стрічки в url.`,\r\n  },\r\n  {\r\n    title: `what is useRouteMatch?`,\r\n    english:`This is a react router hook that provides access to the match object, the purpose of which is to build nested routes.`,\r\n    ukrainian:`Це хук з react router, що надає доступ до об' єкту match, метою якого є побудова вкладених маршрутів.`,\r\n  },\r\n  {\r\n    title: `How to transfer props in react router?`,\r\n    english:`The route component with props in render accepts a function that returns a react element. After that, it is called instead of implementing its own rendering logic. This technique is used to allocate code between components, thanks to props, whose value is a function. In React, such a pattern is called render props`,\r\n    ukrainian:`Компонент route з пропсам в render приймає функцію, яка повертає react елемент. Після чого викликає її замість реалізації власної логіки рендеру. Дана техніка використовується для розприділення коду між компонентами, завдяки пропс, значення якого є функція. В реакт такий паттерн називається render props.`,\r\n  },\r\n  {\r\n    title: `What is reselect? How does it work?`,\r\n    english:`Reselect is a simple library for creating selectors with memoized combination functions. Selectors are used to efficiently compute arbitrary data from the redux repository. Selectors make it possible to store the minimum possible state. Also, the selector is recalculated when its arguments are changed. The selector is not recalculated when unrelated parts of the component tree are changed by the selector. In this way, the redux store can extract data from different places and combine them specifically for the component. these combined data are memorized, and if nothing has changed, no unnecessary re-rendering of the component is caused.`,\r\n    ukrainian:`Reselect - це проста бібліотека для створення селекторів з мемоїзованими комбінованих функцій.  Селектори використовуються для ефективного вичислення довільних даних з redux сховища. Селектори дають можливісь зберігати мінімально можливий стейт. Також селектор вичисляється повторно при зміні його аргументів.Повторне вичислення селектора не відбувається при зміні непов' язаних частин дерева компонента селектором. Таким чином з redux store можна витягувати дані з різних місць і комбінувати їх спеціально для компонента. ці комбіновані дані мемоїзуються і якщо нічого не помінялось то не викликається зайвий перерендеринг компонента.`,\r\n  },\r\n  {\r\n    title: `What is the purpose of componentDidMount() lifecycle method?`,\r\n    english:`componentDidMount() is called immediately after the component (inserted into the tree) is mounted. Initialization that needs DOM nodes should be here. This is the place to make a request to the api. You can immediately call setState() in the componentDidMount(). This ensures that even if render() is called twice in this case, the user will not see the intermediate state.`,\r\n    ukrainian:`componentDidMount() викликається відразу після монтування компонента (вставленого в дерево). Ініціалізація, яка потребує вузлів DOM, має бути тут. Це  місце для створення запиту до апі.Можна негайно викликати setState() у componentDidMount(). Це гарантує, що навіть якщо render() буде викликано двічі в цьому випадку, користувач не побачить проміжний стан.`,\r\n  },\r\n  {\r\n    title: `What is the purpose of componentDidUpdate() lifecycle method`,\r\n    english:`This method is not called for initial rendering. This is the lifecycle method for DOM updates and setState. This is also the place to create api queries if you are comparing current properties with previous properties.`,\r\n    ukrainian:`Цей метод не викликається для початкового рендерингу. Це метод  життєвого циклу для оновлень DOM і setState. Це також місце для створення запитів на апі, якщо ви порівнюєте поточні властивості з попередніми.`,\r\n  },\r\n  {\r\n    title: `What is the purpose of componentWillUnmount() lifecycle method`,\r\n    english:`componentWillUnmount() is called just before the component is unmounted and destroyed. Any necessary cleanup in , such as canceling timers, canceling requests to the api, or cleaning up any subscriptions created in componentDidMount(), is performed here. There is no need to call setState() in componentWillUnmount() because the component will never be remounted. Once a component is unmounted, it will never be mounted again.`,\r\n    ukrainian:`componentWillUnmount() викликається безпосередньо перед тим, як компонент демонтується та знищується. Тут Виконується будь-яке необхідне очищення в , як анулювання таймерів, скасування запитів до апі або очищення будь-яких підписок, створених у componentDidMount(). Не треба викликати setState() у componentWillUnmount(), оскільки компонент ніколи не буде повторно відтворено. Після того як компонент буде демонтовано, він більше ніколи не буде змонтований.`,\r\n  },\r\n  {\r\n    title: `what lifecycle hooks is not exist on functional hooks?`,\r\n    english:`constructor - Functional components do not need a constructor. You can initialize the state in the useState call. If the calculation of the initial state is expensive, then you can pass the function useState.getSnapshotBeforeUpdate, componentDidCatch and getDerivedStateFromError - There are no equivalents in hooks for these methods yet, but I think they will be added soon.`,\r\n    ukrainian:`конструктор - Функціональним компонентам не потрібен конструктор. Ви можете ініціалізувати стейт у виклику useState. Якщо обчислення початкового стану дорого обходиться, то можна передати функцію useState.getSnapshotBeforeUpdate, componentDidCatch і getDerivedStateFromError - Для цих методів ще немає еквівалентів в хуках, але думаю незабаром вони будуть додані.`,\r\n  },\r\n  {\r\n    title: `what lifecycle methods are implemented by useEffect?`,\r\n    english:`componentDidMount, componentDidUpdate, componentWillUnmount`,\r\n    ukrainian:`componentDidMount, componentDidUpdate, componentWillUnmount`,\r\n  },\r\n  {\r\n    title: `how the re-rendering works in react?`,\r\n    english: `Re-rendering is triggered when a state is updated or a property in a component is changed. The component that initiated the state change is marked and re-rendered, and all child components are also re-rendered. This process looks as follows: - The component that initiated the state change is marked; - This component and its child components are parsed and then JSX converted to React elements using React.createElement and stored in memory; - A new virtual DOM is created using React elements and then compared to the previous virtual DOM using a difference algorithm. Changes are sent to the commit stage. React uses the Object.is comparison algorithm, so state changes should be immutable.`,\r\n    ukrainian: `Ререндеринг запускається, коли оновлюється стейт або змінюється властивість у компоненті. Компонент, який ініціював зміну стейту, позначається та повторно відображається, і всі дочірні компоненти також повторно відображаються. Цей процес виглядає виглядаэ наступним чином: - Позначаэться компонент, який ініціював зміну стейту; - Цей компонент і його дочірні компоненти аналізуються, а потім JSX перетворюється на елементи React за допомогою React.createElement і зберігається в пам’яті; - Новий віртуальний DOM створюється за допомогою елементів React, а потім порівнюється з попереднім віртуальним DOM за допомогою алгоритму відмінності. Зміни надсилаються на етап фіксації. React використовує алгоритм порівняння Object.is, тому зміни стейту повинні бути незмінними.`,\r\n  },\r\n  {\r\n    title: `useMemo vs useCallback`,\r\n    english: `The main difference between useMemo and useCallback hook is, useMemo returns memoized value and useCallback returns memoised function.`,\r\n    ukrainian: `Основна відмінність між useMemo і useCallback хуком полягає в тому, що useMemo повертає мемоізоване значення, а useCallback повертає мемоізовану функцію.`,\r\n  },\r\n  {\r\n    title: `What is useContext`,\r\n    english: `A context is a method of passing data or information through a tree of components without manually sending attributes through each nested component. It is specifically designed to share data that can be considered generic data for a tree composed of React components, such as the current user authentication status or a theme (eg color, padding, margins, font size). Basically, to get the data from the lowest child component, we need to use the properties in each component. To avoid this pain, we use the useContext hook.`,\r\n    ukrainian: `Контекст — це метод передачі даних або інформації через дерево компонентів без надсилання атрибутів вручну через кожен вкладений компонент. Він спеціально розроблений для обміну даними, які можна вважати загальними даними для дерева, що складається з компонентів React, як-от поточний статус автентифікації користувача або тема (наприклад, колір, відступи, поля, розмір шрифту). В основному, щоб отримати дані з найнижчого дочірнього компонента, нам потрібно використовувати властивості в кожному компоненті. Щоб уникнути цього болю, ми використовуємо хук useContext.`,\r\n  },\r\n  {\r\n    title: `How to save previous state of the component?`,\r\n    english: `by using useRef hook I can save the previous state. I can access the previous state through setState the asynchronous function`,\r\n    ukrainian: `за допомогою хука useRef я можу зберегти попередній стан. Я можу отримати доступ до попереднього стану через асинхронну функцію setState`,\r\n  },\r\n  {\r\n    title: `How to pass data from child to parent`,\r\n    english: `You need to create a callback in the parent component. This callback will receive data from the child component. You need to pass the callback in the parent component as a prop to the child component. And the child component calls the callback using props`,\r\n    ukrainian: `Треба створити колбек в батьківському компоненті. Цей колбек отримає дані від дочірнього компонента. Потрібно передати колбек в батьківському компоненті як проп до дочірнього компонента. І дочірній компонент викликає колбек за допомогою props`,\r\n  },\r\n  {\r\n    title: `how to pass ref between the components?`,\r\n    english: `In general, the \"ref\" function is an anti-pattern in React. It exists to enable side-effect-driven development. To get the most out of React, you should try to avoid \"refs\" if possible. Basically a chicken vs egg scenario. The ref callback is fired when the child element is mounted, not when it is rendered, . One thing you could try is to cast the ref to a state and then read from the state to another child element.`,\r\n    ukrainian: `Загалом функція «ref» є антипаттерном у React. Вона є для того, щоб уможливити розробку, керовану побічними ефектами. Щоб отримати максимальну вигоду від React, треба намагатися уникати «рефів», якщо це можливо. Загалом є сценарієм «курка проти яйця». Зворотний виклик ref запускається під час монтування дочірнього елемента, а не під час рендерингу, . Одна річ, яку ви можете спробувати, це перевести ref у стан, а потім прочитати зі стейту в інший дочірній елемент.`,\r\n  },\r\n  {\r\n    title: `What is Redux and why it is used?`,\r\n    english: `Redux is a predictable state container. It is mostly used as a state management tool with React. although you can use it with any other JavaScript framework or library.`,\r\n    ukrainian: `Redux — це контейнер передбачуваного стейту.він здебільшого використовується як інструмент керування станом із React. хоча його можна використовувати його з будь-яким іншим фреймворком чи бібліотекою JavaScript.`,\r\n  },\r\n  {\r\n    title: `What are 3 main concepts of Redux?`,\r\n    english: ` - Single source of truth: The global state of your application is stored in an object tree within a single store. ... - State is read-only: The only way to change the state is to emit an action, an object describing what happened. ... - Changes are made with pure function`,\r\n    ukrainian: `- Єдине джерело істини: Глобальний стан вашої програми зберігається в дереві об’єктів в одному сховищі. ... - Стан доступний лише для читання: Єдиний спосіб змінити стан - створити дію, об'єкт, який описує те, що сталося. ... - Зміни вносяться за допомогою чистих функцій`,\r\n  },\r\n  {\r\n    title: `What is difference between React and Redux?`,\r\n    english: `Redux manages state and state transformations and is often used with React, but React has its own concept of state.`,\r\n    ukrainian: `Redux керує станом і перетвореннями стану та часто використовується з React, але React має власну концепцію стану.`,\r\n  },\r\n  {\r\n    title: `Why use Redux instead of context API?`,\r\n    english: `Redux is a complete state manager capable of allowing an app to undo/redo actions and provides advanced developer tooling for debugging. Context API is designed as a dependency injection mechanism that allows making data available through the component tree without being manually passed`,\r\n    ukrainian: `Redux — це повний менеджер стану, який дозволяє програмі скасовувати/повторювати дії та надає розширені інструменти розробника для налагодження. Context API розроблено як механізм ін’єкції залежностей, який дозволяє робити дані доступними через дерево компонентів без передачі вручну`,\r\n  },\r\n  {\r\n    title: `what does the redux consist of?`,\r\n    english: `Redux has three main components that make the Redux system work. The components are Store, Actions and Reducer. Store is an object that contains the current state of the machine. Every piece of information we need on the car will be stored inside the store. In addition, the store is also responsible for handling all components that want to know the current state or change the current state. Action is an object that defines what action we can perform inside the system and change its state. But remember that an action doesn't specify how it should change the state, it just acts as a verbal definition or list. And finally, the reducer acts as a definition of a specific action. Thus, there will be one reducer for each action we define inside the system`,\r\n    ukrainian: `У Redux є три основні компоненти, завдяки яким система Redux працює. Компонентами є Store, Actions і Reducer. Store - це об'єкт, який містить поточний стейт. Кожна інформація, яка нам потрібна зі стейту, зберігатиметься всередині стору. Окрім цього, стор також відповідає за обробку всіх компонентів, які хочуть знати поточний стан або змінити поточний стан. Action – це об’єкт, який визначає, яку дію ми можемо виконувати всередині системи та змінювати її стан. Але пам’ятайте, що дія не визначає, як вона має змінити стан, вона просто діє як словесне визначення або перелік. І останнє, редюсер виступає як визначення конкретної дії. Таким чином, для кожної дії, яку ми визначаємо всередині системи, буде один редюсер`,\r\n  },\r\n  {\r\n    title: `What is mapStateToProps used for?`,\r\n    english: `As the first argument passed to the connection, mapStateToProps is used to select a piece of data from storage that the connected component needs. It is often called simply mapState for brevity. It is called every time the redax of the store is changed.`,\r\n    ukrainian: `Як перший аргумент, переданий для підключення, mapStateToProps використовується для вибору частини даних зі сховища, яка потрібна підключеному компоненту. Його часто називають просто mapState для стислості. Він викликається кожного разу, коли змінюється стан сховища .`,\r\n  },\r\n  {\r\n    title: `When mapDispatchToProps is called?`,\r\n    english: `If your mapDispatchToProps function is declared as taking two parameters, it will be called with dispatch as the first parameter and the props passed to the connected component as the second parameter, and will be re-invoked whenever the connected component receives new props`,\r\n    ukrainian: `Якщо ваша функція mapDispatchToProps оголошена як така, що приймає два параметри, її буде викликано з dispatch як першим параметром, а властивості, передані підключеному компоненту як другий параметр, і будуть повторно викликані щоразу, коли підключений компонент отримає нові властивості`,\r\n  },\r\n  {\r\n    title: `What is the difference between mapStateToProps() and mapDispatchToProps() in React?`,\r\n    english: `mapStateToProps() is a utility that helps your component get updated state (which is updated by some other components), mapDispatchToProps() is a utility that helps the component launch exkins (a dispatcher action that can cause a state change)`,\r\n    ukrainian: `mapStateToProps() — це утиліта, яка допомагає вашому компоненту отримувати оновлений стейт (який оновлюється деякими іншими компонентами), mapDispatchToProps() — це утиліта, яка допомогає компоненту запустити екшини(дія диспетчера, яка може спричинити зміну стейту)`,\r\n  },\r\n  {\r\n    title: `What does redux-thunk do?`,\r\n    english: `The word \"thunk\" in programming means \"a piece of code that performs some delayed work.\" For Redux, thunks are a template for writing functions with internal logic that can interact with the dispatch and getState methods of the Redux store.`,\r\n    ukrainian: `Слово \"thunk\" - в програмуванні означає \"фрагмент коду, який виконує деяку відкладену роботу\". Для Redux «thunks» — це темплейт написання функцій із внутрішньою логікою, які можуть взаємодіяти з методами dispatch і getState ма Redux сховища.`,\r\n  },\r\n  {\r\n    title: `What is the purpose of redux-thunk?`,\r\n    english: `Thunk allows us to send actions manually, which allows us to include some logic or run some asynchronous code before sending the action.`,\r\n    ukrainian: `Thunk дозволяє нам відправляти екшени вручну, що дає можливість включити деяку логіку або запустити деякий асинхронний код перед відправленням екшена.`,\r\n  },\r\n\r\n] as Question[]\r\n\r\n// redux toolkit, saga, react query, usequery\r\n\r\n\r\n\r\n","import {angularArray} from \"./angular.array\";\r\nimport {reactArray} from \"./react.array\";\r\nimport {nodejsArray} from \"./nodejs.array\";\r\nimport {Question} from \"../question.interface\";\r\n\r\nexport enum techStackEnum {\r\n  ANGULAR = 'angular',\r\n  REACT = 'react',\r\n  NODEJS = 'nodejs'\r\n}\r\n\r\nexport type TechStackType = {\r\n  [key in techStackEnum]: Question[]\r\n}\r\n\r\nexport const techStack = {\r\n  [techStackEnum.ANGULAR]: angularArray,\r\n  [techStackEnum.REACT]: reactArray,\r\n  [techStackEnum.NODEJS]: nodejsArray\r\n} as TechStackType\r\n\r\n\r\n\r\n","import { Pipe, PipeTransform } from '@angular/core';\nimport {Question} from \"../question.interface\";\n\n@Pipe({\n  name: 'filter'\n})\nexport class FilterPipe implements PipeTransform {\n\n  transform(items: Question[], value: string): Question[] {\n    if (!items) return [];\n    if(value) {\n      return items.filter(({title, english, ukrainian}) => {\n        return(\n          title.toLocaleLowerCase().indexOf(value.toLocaleLowerCase()) > -1\n          ||\n          english?.toLocaleLowerCase().indexOf(value.toLocaleLowerCase()) > -1\n          ||\n          ukrainian?.toLocaleLowerCase().indexOf(value.toLocaleLowerCase()) > -1\n        )\n      });\n\n    }\n    else {\n      return items;\n    }\n  }\n\n}\n","import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'highlighter'\n})\nexport class HighlighterPipe implements PipeTransform {\n\n  public transform(value: string, predicate: string): string {\n    if(!predicate){\n      return value;\n    }\n    return value?.replace(new RegExp(predicate, 'gi'), `<mark>${predicate}</mark>`);\n    }\n\n}\n","// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  production: false\n};\n\n/*\n * For easier debugging in development mode, you can import the following file\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\n *\n * This import should be commented out in production mode because it will have a negative impact\n * on performance if an error is thrown.\n */\n// import 'zone.js/plugins/zone-error';  // Included with Angular CLI.\n","import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n"],"names":["angularArray","title","english","ukrainian","reactArray"],"sourceRoot":"webpack:///","x_google_ignoreList":[]}